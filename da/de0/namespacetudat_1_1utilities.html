<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Tudat: tudat::utilities Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tudat
   </div>
   <div id="projectbrief">TU Delft astrodynamics toolbox</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d6/d6d/namespacetudat.html">tudat</a></li><li class="navelem"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html">utilities</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tudat::utilities Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae4a4a66c9bde0984a58a3dc292d9213f"><td class="memTemplParams" colspan="2">template&lt;typename Argument &gt; </td></tr>
<tr class="memitem:ae4a4a66c9bde0984a58a3dc292d9213f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Argument &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#ae4a4a66c9bde0984a58a3dc292d9213f">addScalarToVector</a> (const std::vector&lt; Argument &gt; &amp;vector, const double scalar)</td></tr>
<tr class="memdesc:ae4a4a66c9bde0984a58a3dc292d9213f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add a double to all entries in an STL vector.  <a href="#ae4a4a66c9bde0984a58a3dc292d9213f">More...</a><br /></td></tr>
<tr class="separator:ae4a4a66c9bde0984a58a3dc292d9213f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f97484a4f7f2e8ecf91f4fd8c7c7cc2"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename U , typename V , int Rows, int Columns&gt; </td></tr>
<tr class="memitem:a0f97484a4f7f2e8ecf91f4fd8c7c7cc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a0f97484a4f7f2e8ecf91f4fd8c7c7cc2">castMatrixMap</a> (const std::map&lt; S, Eigen::Matrix&lt; T, Rows, Columns &gt; &gt; &amp;originalMap, std::map&lt; U, Eigen::Matrix&lt; V, Rows, Columns &gt; &gt; &amp;newTypesMap)</td></tr>
<tr class="memdesc:a0f97484a4f7f2e8ecf91f4fd8c7c7cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to cast a map of <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrices from one key/matrix scalar type set to another set.  <a href="#a0f97484a4f7f2e8ecf91f4fd8c7c7cc2">More...</a><br /></td></tr>
<tr class="separator:a0f97484a4f7f2e8ecf91f4fd8c7c7cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae084b530a39126d9f71b9564a1795c4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae084b530a39126d9f71b9564a1795c4a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#ae084b530a39126d9f71b9564a1795c4a">convertEigenVectorToStlVector</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;eigenVector)</td></tr>
<tr class="separator:ae084b530a39126d9f71b9564a1795c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad8ef028c0ca96f764a938016c7a01b"><td class="memTemplParams" colspan="2">template&lt;typename MapKey , typename ScalarType &gt; </td></tr>
<tr class="memitem:acad8ef028c0ca96f764a938016c7a01b"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; MapKey, Eigen::Array&lt; ScalarType, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#acad8ef028c0ca96f764a938016c7a01b">convertSTLVectorMapToEigenVectorMap</a> (std::map&lt; MapKey, std::vector&lt; ScalarType &gt; &gt; stlVectorMap)</td></tr>
<tr class="memdesc:acad8ef028c0ca96f764a938016c7a01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform from map of std::vector (output of text file reader) to map of Eigen::Array.  <a href="#acad8ef028c0ca96f764a938016c7a01b">More...</a><br /></td></tr>
<tr class="separator:acad8ef028c0ca96f764a938016c7a01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6185604e1e88e807107fba0d5fcd0b81"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6185604e1e88e807107fba0d5fcd0b81"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a6185604e1e88e807107fba0d5fcd0b81">convertStlVectorToEigenVector</a> (const std::vector&lt; T &gt; &amp;stlVector)</td></tr>
<tr class="separator:a6185604e1e88e807107fba0d5fcd0b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76098cf72d99535ce14d506f507c2ed5"><td class="memTemplParams" colspan="2">template&lt;typename S , int NumberOfDimensions&gt; </td></tr>
<tr class="memitem:a76098cf72d99535ce14d506f507c2ed5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a76098cf72d99535ce14d506f507c2ed5">copyMultiArray</a> (const boost::multi_array&lt; S, NumberOfDimensions &gt; &amp;arrayToCopy, boost::multi_array&lt; S, NumberOfDimensions &gt; &amp;targetArray)</td></tr>
<tr class="memdesc:a76098cf72d99535ce14d506f507c2ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to copy a multi-array into another multi-array.  <a href="#a76098cf72d99535ce14d506f507c2ed5">More...</a><br /></td></tr>
<tr class="separator:a76098cf72d99535ce14d506f507c2ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8826e25d6f4baf3d1034c2b8237d0c5d"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , typename ScalarType , int NumberOfRows, int NumberOfColumns = 1&gt; </td></tr>
<tr class="memitem:a8826e25d6f4baf3d1034c2b8237d0c5d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; ScalarType, Eigen::Dynamic, NumberOfColumns &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a8826e25d6f4baf3d1034c2b8237d0c5d">createConcatenatedEigenMatrixFromMapValues</a> (const std::map&lt; KeyType, Eigen::Matrix&lt; ScalarType, NumberOfRows, NumberOfColumns &gt; &gt; &amp;inputMap)</td></tr>
<tr class="separator:a8826e25d6f4baf3d1034c2b8237d0c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03307b67bd8ee0129a64107e1014a78a"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:a03307b67bd8ee0129a64107e1014a78a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a03307b67bd8ee0129a64107e1014a78a">createVectorBlockMatrixHistory</a> (const std::map&lt; S, Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt; &amp;matrixHistory, std::map&lt; S, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt; &amp;blockMatrixHistory, const std::pair&lt; int, int &gt; startIndices, const int segmentSize)</td></tr>
<tr class="memdesc:a03307b67bd8ee0129a64107e1014a78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a vector block history from full matrix history.  <a href="#a03307b67bd8ee0129a64107e1014a78a">More...</a><br /></td></tr>
<tr class="separator:a03307b67bd8ee0129a64107e1014a78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff6b03086e9d46b54a9a9b0147e3126"><td class="memTemplParams" colspan="2">template&lt;typename VectorArgument , typename KeyType &gt; </td></tr>
<tr class="memitem:a7ff6b03086e9d46b54a9a9b0147e3126"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; KeyType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a7ff6b03086e9d46b54a9a9b0147e3126">createVectorFromMapKeys</a> (const std::map&lt; KeyType, VectorArgument &gt; &amp;inputMap)</td></tr>
<tr class="memdesc:a7ff6b03086e9d46b54a9a9b0147e3126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a vector from the keys of a map.  <a href="#a7ff6b03086e9d46b54a9a9b0147e3126">More...</a><br /></td></tr>
<tr class="separator:a7ff6b03086e9d46b54a9a9b0147e3126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ffa5bbb8bf510a4e3942a82e36d63c"><td class="memTemplParams" colspan="2">template&lt;typename VectorArgument , typename KeyType &gt; </td></tr>
<tr class="memitem:ab7ffa5bbb8bf510a4e3942a82e36d63c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; VectorArgument &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#ab7ffa5bbb8bf510a4e3942a82e36d63c">createVectorFromMapValues</a> (const std::map&lt; KeyType, VectorArgument &gt; &amp;inputMap)</td></tr>
<tr class="memdesc:ab7ffa5bbb8bf510a4e3942a82e36d63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a vector from the values of a map.  <a href="#ab7ffa5bbb8bf510a4e3942a82e36d63c">More...</a><br /></td></tr>
<tr class="separator:ab7ffa5bbb8bf510a4e3942a82e36d63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296cc0b23594eca7a78a8500ee568af6"><td class="memTemplParams" colspan="2">template&lt;typename VectorArgument , typename KeyType &gt; </td></tr>
<tr class="memitem:a296cc0b23594eca7a78a8500ee568af6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; KeyType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a296cc0b23594eca7a78a8500ee568af6">createVectorFromMultiMapKeys</a> (const std::multimap&lt; KeyType, VectorArgument &gt; &amp;inputMap)</td></tr>
<tr class="memdesc:a296cc0b23594eca7a78a8500ee568af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a vector from the keys of a multimap.  <a href="#a296cc0b23594eca7a78a8500ee568af6">More...</a><br /></td></tr>
<tr class="separator:a296cc0b23594eca7a78a8500ee568af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae625adfdbd740bfdf4c5843bd0c4e414"><td class="memTemplParams" colspan="2">template&lt;typename VectorArgument , typename KeyType &gt; </td></tr>
<tr class="memitem:ae625adfdbd740bfdf4c5843bd0c4e414"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; VectorArgument &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#ae625adfdbd740bfdf4c5843bd0c4e414">createVectorFromMultiMapValues</a> (const std::multimap&lt; KeyType, VectorArgument &gt; &amp;inputMap)</td></tr>
<tr class="memdesc:ae625adfdbd740bfdf4c5843bd0c4e414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a vector from the values of a multimap.  <a href="#ae625adfdbd740bfdf4c5843bd0c4e414">More...</a><br /></td></tr>
<tr class="separator:ae625adfdbd740bfdf4c5843bd0c4e414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855f3e9a1ac6f189ecb64eca19bc1c76"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:a855f3e9a1ac6f189ecb64eca19bc1c76"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a855f3e9a1ac6f189ecb64eca19bc1c76">createVectorFromVectorOfPairFirsts</a> (const std::vector&lt; std::pair&lt; S, T &gt; &gt; inputVector)</td></tr>
<tr class="separator:a855f3e9a1ac6f189ecb64eca19bc1c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3729d39dbee0d760df4a34697f77d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3c3729d39dbee0d760df4a34697f77d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a3c3729d39dbee0d760df4a34697f77d5">doStlVectorContentsMatch</a> (const std::vector&lt; T &gt; &amp;vectorA, const std::vector&lt; T &gt; &amp;vectorB)</td></tr>
<tr class="separator:a3c3729d39dbee0d760df4a34697f77d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1880bad9d4c399eca13fd428964d740"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:ab1880bad9d4c399eca13fd428964d740"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#ab1880bad9d4c399eca13fd428964d740">dynamicCastSVectorToTVector</a> (const std::vector&lt; boost::shared_ptr&lt; S &gt; &gt; &amp;originalVector)</td></tr>
<tr class="memdesc:ab1880bad9d4c399eca13fd428964d740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to dynamic cast vector of shared pointers of one type to shared pointers of another type.  <a href="#ab1880bad9d4c399eca13fd428964d740">More...</a><br /></td></tr>
<tr class="separator:ab1880bad9d4c399eca13fd428964d740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cda666d038748d59988f002cdad36d3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a6cda666d038748d59988f002cdad36d3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a6cda666d038748d59988f002cdad36d3">evaluateFunctionWithoutInputArgumentDependency</a> (boost::function&lt; T() &gt; inputFreeFunction, const S dummyInput)</td></tr>
<tr class="separator:a6cda666d038748d59988f002cdad36d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55fb61a3bac2792775a0dad47b26e61"><td class="memTemplParams" colspan="2">template&lt;unsigned int NumberOfDimensions&gt; </td></tr>
<tr class="memitem:ae55fb61a3bac2792775a0dad47b26e61"><td class="memTemplItemLeft" align="right" valign="top">boost::multi_array&lt; double,NumberOfDimensions &gt;::index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#ae55fb61a3bac2792775a0dad47b26e61">getMultiArrayIndex</a> (const typename boost::multi_array&lt; double, NumberOfDimensions &gt; &amp;multiArray, const double *requestedElement, const unsigned short int direction)</td></tr>
<tr class="memdesc:ae55fb61a3bac2792775a0dad47b26e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index in nth direction of pointer to single entry in multi-array of doubles.  <a href="#ae55fb61a3bac2792775a0dad47b26e61">More...</a><br /></td></tr>
<tr class="separator:ae55fb61a3bac2792775a0dad47b26e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba292560800158a5631f439aac326fd"><td class="memItemLeft" align="right" valign="top">boost::array&lt; boost::multi_array&lt; double, 1 &gt;::index, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#abba292560800158a5631f439aac326fd">getMultiArrayIndexArray</a> (const boost::multi_array&lt; double, 1 &gt; &amp;multiArray, const double *requestedElement)</td></tr>
<tr class="memdesc:abba292560800158a5631f439aac326fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indices of pointer to single entry in multi-array (size 1) of doubles.  <a href="#abba292560800158a5631f439aac326fd">More...</a><br /></td></tr>
<tr class="separator:abba292560800158a5631f439aac326fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52273ae41a9cf75389b839cbad7e1bea"><td class="memItemLeft" align="right" valign="top">boost::array&lt; boost::multi_array&lt; double, 2 &gt;::index, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a52273ae41a9cf75389b839cbad7e1bea">getMultiArrayIndexArray</a> (const boost::multi_array&lt; double, 2 &gt; &amp;multiArray, const double *requestedElement)</td></tr>
<tr class="memdesc:a52273ae41a9cf75389b839cbad7e1bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indices of pointer to single entry in multi-array (size 2) of doubles.  <a href="#a52273ae41a9cf75389b839cbad7e1bea">More...</a><br /></td></tr>
<tr class="separator:a52273ae41a9cf75389b839cbad7e1bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c60559e4cf7a6fd604383f22ff2104"><td class="memItemLeft" align="right" valign="top">boost::array&lt; boost::multi_array&lt; double, 3 &gt;::index, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a07c60559e4cf7a6fd604383f22ff2104">getMultiArrayIndexArray</a> (const boost::multi_array&lt; double, 3 &gt; &amp;multiArray, const double *requestedElement)</td></tr>
<tr class="memdesc:a07c60559e4cf7a6fd604383f22ff2104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indices of pointer to single entry in multi-array (size 3) of doubles.  <a href="#a07c60559e4cf7a6fd604383f22ff2104">More...</a><br /></td></tr>
<tr class="separator:a07c60559e4cf7a6fd604383f22ff2104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cdd935427a4cca8218aae7e2d6e408"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93cdd935427a4cca8218aae7e2d6e408"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a93cdd935427a4cca8218aae7e2d6e408">getSortOrderOfVector</a> (const std::vector&lt; T &gt; unsortedVector)</td></tr>
<tr class="memdesc:a93cdd935427a4cca8218aae7e2d6e408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the order in which the input vector would be sorted (in ascending order)  <a href="#a93cdd935427a4cca8218aae7e2d6e408">More...</a><br /></td></tr>
<tr class="separator:a93cdd935427a4cca8218aae7e2d6e408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553717c9b01a377e5fbb47f9f3b596d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a553717c9b01a377e5fbb47f9f3b596d2"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a553717c9b01a377e5fbb47f9f3b596d2">getSortOrderOfVectorAndSortedVector</a> (const std::vector&lt; T &gt; unsortedVector)</td></tr>
<tr class="memdesc:a553717c9b01a377e5fbb47f9f3b596d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get sorted vector of an input vector, as well as the order in which this input has been be sorted (ascending)  <a href="#a553717c9b01a377e5fbb47f9f3b596d2">More...</a><br /></td></tr>
<tr class="separator:a553717c9b01a377e5fbb47f9f3b596d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a43245367b57d45bd45d227d7c66bd"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:a37a43245367b57d45bd45d227d7c66bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a37a43245367b57d45bd45d227d7c66bd">printMapContents</a> (const std::map&lt; S, T &gt; &amp;mapToPrint)</td></tr>
<tr class="memdesc:a37a43245367b57d45bd45d227d7c66bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to print the contents of a map, line by line.  <a href="#a37a43245367b57d45bd45d227d7c66bd">More...</a><br /></td></tr>
<tr class="separator:a37a43245367b57d45bd45d227d7c66bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8f8cc810c26601f9367f2092167951"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:adb8f8cc810c26601f9367f2092167951"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#adb8f8cc810c26601f9367f2092167951">subtractFunctionReturn</a> (const boost::function&lt; S() &gt; function1, const boost::function&lt; S() &gt; function2)</td></tr>
<tr class="memdesc:adb8f8cc810c26601f9367f2092167951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to subtract the return values of two boost function with empty input argument list.  <a href="#adb8f8cc810c26601f9367f2092167951">More...</a><br /></td></tr>
<tr class="separator:adb8f8cc810c26601f9367f2092167951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f1269780bbde2d2201d22b9726e8db"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:af9f1269780bbde2d2201d22b9726e8db"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#af9f1269780bbde2d2201d22b9726e8db">sumFunctionReturn</a> (const boost::function&lt; S() &gt; function1, const boost::function&lt; S() &gt; function2)</td></tr>
<tr class="memdesc:af9f1269780bbde2d2201d22b9726e8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to sum the return values of two boost function with empty input argument list.  <a href="#af9f1269780bbde2d2201d22b9726e8db">More...</a><br /></td></tr>
<tr class="separator:af9f1269780bbde2d2201d22b9726e8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="abba292560800158a5631f439aac326fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::array&lt; boost::multi_array&lt; double, 1 &gt;::index, 1 &gt; tudat::utilities::getMultiArrayIndexArray </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>requestedElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get indices of pointer to single entry in multi-array (size 1) of doubles </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiArray</td><td>Multi-array for which the index is to be retrieved </td></tr>
    <tr><td class="paramname">requestedElement</td><td>Pointer to element for which index is to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indices of pointer to single entry in multi-array of doubles </dd></dl>

<p>Definition at line <a class="el" href="../../de/da5/utilities_8cpp_source.html#l00020">20</a> of file <a class="el" href="../../de/da5/utilities_8cpp_source.html">utilities.cpp</a>.</p>

<p>Referenced by <a class="el" href="../../de/df0/utilities_8h_source.html#l00321">getMultiArrayIndex()</a>, and <a class="el" href="../../dd/d94/aerodynamic_coefficient_reader_8h_source.html#l00034">tudat::input_output::mergeNDimensionalCoefficients()</a>.</p>

</div>
</div>
<a class="anchor" id="a52273ae41a9cf75389b839cbad7e1bea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::array&lt; boost::multi_array&lt; double, 2 &gt;::index, 2 &gt; tudat::utilities::getMultiArrayIndexArray </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>requestedElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get indices of pointer to single entry in multi-array (size 2) of doubles </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiArray</td><td>Multi-array for which the index is to be retrieved </td></tr>
    <tr><td class="paramname">requestedElement</td><td>Pointer to element for which index is to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indices of pointer to single entry in multi-array of doubles </dd></dl>

<p>Definition at line <a class="el" href="../../de/da5/utilities_8cpp_source.html#l00035">35</a> of file <a class="el" href="../../de/da5/utilities_8cpp_source.html">utilities.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07c60559e4cf7a6fd604383f22ff2104"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::array&lt; boost::multi_array&lt; double, 3 &gt;::index, 3 &gt; tudat::utilities::getMultiArrayIndexArray </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>requestedElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get indices of pointer to single entry in multi-array (size 3) of doubles </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiArray</td><td>Multi-array for which the index is to be retrieved </td></tr>
    <tr><td class="paramname">requestedElement</td><td>Pointer to element for which index is to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indices of pointer to single entry in multi-array of doubles </dd></dl>

<p>Definition at line <a class="el" href="../../de/da5/utilities_8cpp_source.html#l00050">50</a> of file <a class="el" href="../../de/da5/utilities_8cpp_source.html">utilities.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7ffa5bbb8bf510a4e3942a82e36d63c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorArgument , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; VectorArgument &gt; tudat::utilities::createVectorFromMapValues </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; KeyType, VectorArgument &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to create a vector from the values of a map. The output vector is in the order of the map entries, i.e. as provided by a forward iterator. The map keys are not used for the return vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputMap</td><td>Original map from which the vector is to be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector created from the map values </dd></dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00039">39</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

<p>Referenced by <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00174">tudat::linear_algebra::getLeastSquaresPolynomialFit()</a>, and <a class="el" href="../../d3/db7/multi_arc_ephemeris_8h_source.html#l00143">tudat::ephemerides::MultiArcEphemeris::resetSingleArcEphemerides()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ff6b03086e9d46b54a9a9b0147e3126"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorArgument , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; KeyType &gt; tudat::utilities::createVectorFromMapKeys </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; KeyType, VectorArgument &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to create a vector from the keys of a map. The output vector is in the order of the map entries, i.e. as provided by a forward iterator. The map values are not used for the return vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputMap</td><td>Original map from which the vector is to be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector created from the map keys </dd></dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00066">66</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

<p>Referenced by <a class="el" href="../../df/de7/create_observation_partials_8h_source.html#l00256">tudat::observation_partials::ObservationPartialCreator&lt; 1, ObservationScalarType, TimeType &gt;::createObservationPartials()</a>, <a class="el" href="../../df/de7/create_observation_partials_8h_source.html#l00322">tudat::observation_partials::ObservationPartialCreator&lt; 2, ObservationScalarType, TimeType &gt;::createObservationPartials()</a>, <a class="el" href="../../df/de7/create_observation_partials_8h_source.html#l00374">tudat::observation_partials::ObservationPartialCreator&lt; 3, ObservationScalarType, TimeType &gt;::createObservationPartials()</a>, <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00174">tudat::linear_algebra::getLeastSquaresPolynomialFit()</a>, <a class="el" href="../../d3/db7/multi_arc_ephemeris_8h_source.html#l00143">tudat::ephemerides::MultiArcEphemeris::resetSingleArcEphemerides()</a>, <a class="el" href="../../dd/d82/aerodynamic_coefficient_interface_8h_source.html#l00289">tudat::aerodynamics::AerodynamicCoefficientInterface::setControlSurfaceIncrements()</a>, <a class="el" href="../../d5/dd7/variational_equations_solver_8h_source.html#l00820">tudat::propagators::setPropagatorSettingsMultiArcStatesInEstimatedDynamicalParameters()</a>, and <a class="el" href="../../d0/dc9/observation_simulator_8h_source.html#l00077">tudat::observation_models::simulateObservationsWithCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="af9f1269780bbde2d2201d22b9726e8db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">S tudat::utilities::sumFunctionReturn </td>
          <td>(</td>
          <td class="paramtype">const boost::function&lt; S() &gt;&#160;</td>
          <td class="paramname"><em>function1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::function&lt; S() &gt;&#160;</td>
          <td class="paramname"><em>function2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to sum the return values of two boost function with empty input argument list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function1</td><td>First function to be added. </td></tr>
    <tr><td class="paramname">function2</td><td>Second function to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of return values of function1 and function2 </dd></dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00092">92</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a class="anchor" id="adb8f8cc810c26601f9367f2092167951"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">S tudat::utilities::subtractFunctionReturn </td>
          <td>(</td>
          <td class="paramtype">const boost::function&lt; S() &gt;&#160;</td>
          <td class="paramname"><em>function1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::function&lt; S() &gt;&#160;</td>
          <td class="paramname"><em>function2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to subtract the return values of two boost function with empty input argument list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function1</td><td>First function to be subtracted from. </td></tr>
    <tr><td class="paramname">function2</td><td>Second function to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return values of function1 - return value of function2 </dd></dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00105">105</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a class="anchor" id="a03307b67bd8ee0129a64107e1014a78a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tudat::utilities::createVectorBlockMatrixHistory </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; S, Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrixHistory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; S, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>blockMatrixHistory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>startIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>segmentSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to create a vector matrix block history from full matrix history. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrixHistory</td><td>Full matrix history </td></tr>
    <tr><td class="paramname">blockMatrixHistory</td><td>Block vector history (return by reference). </td></tr>
    <tr><td class="paramname">startIndices</td><td>Starting point (row,column) in matrix of return vector blocks. </td></tr>
    <tr><td class="paramname">segmentSize</td><td>Number of rows in vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00119">119</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

<p>Referenced by <a class="el" href="../../d5/dd7/variational_equations_solver_8h_source.html#l00605">tudat::propagators::SingleArcVariationalEquationsSolver&lt; StateScalarType, TimeType &gt;::integrateVariationalAndDynamicalEquations()</a>, and <a class="el" href="../../d5/dd7/variational_equations_solver_8h_source.html#l01067">tudat::propagators::MultiArcVariationalEquationsSolver&lt; StateScalarType, TimeType &gt;::integrateVariationalAndDynamicalEquations()</a>.</p>

</div>
</div>
<a class="anchor" id="a37a43245367b57d45bd45d227d7c66bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tudat::utilities::printMapContents </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; S, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapToPrint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to print the contents of a map, line by line. Both the key and value types must have the &lt;&lt; operator defined </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapToPrint</td><td>Map that is to be printed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00142">142</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

<p>Referenced by <a class="el" href="../../d8/d7e/dynamics_simulator_8h_source.html#l00282">tudat::propagators::SingleArcDynamicsSimulator&lt; StateScalarType, TimeType &gt;::SingleArcDynamicsSimulator()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f97484a4f7f2e8ecf91f4fd8c7c7cc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename U , typename V , int Rows, int Columns&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tudat::utilities::castMatrixMap </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; S, Eigen::Matrix&lt; T, Rows, Columns &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>originalMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; U, Eigen::Matrix&lt; V, Rows, Columns &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>newTypesMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to produce a map of <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrices, cast from one set of key/matrix scalar type set to another set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalMap</td><td>Map in original types </td></tr>
    <tr><td class="paramname">newTypesMap</td><td>Map that is to be created (returned by reference). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00158">158</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab1880bad9d4c399eca13fd428964d740"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; boost::shared_ptr&lt; T &gt; &gt; tudat::utilities::dynamicCastSVectorToTVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; boost::shared_ptr&lt; S &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>originalVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to dynamic cast vector of shared pointers of one type (S) to shared pointers of another type (T). The dynamic cast must be permissible, i.e. an S pointer must succesfully dynamic cast to a T pointer (T shoudl typically derive from S). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalVector</td><td>Vector of S shared pointers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dynamic casted vector of T shared pointers. </dd></dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00177">177</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

<p>Referenced by <a class="el" href="../../db/dec/create_acceleration_partials_8cpp_source.html#l00022">tudat::simulation_setup::createTidalLoveNumberInterfaces()</a>.</p>

</div>
</div>
<a class="anchor" id="a8826e25d6f4baf3d1034c2b8237d0c5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ScalarType , int NumberOfRows, int NumberOfColumns = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; ScalarType, Eigen::Dynamic, NumberOfColumns &gt; tudat::utilities::createConcatenatedEigenMatrixFromMapValues </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; KeyType, Eigen::Matrix&lt; ScalarType, NumberOfRows, NumberOfColumns &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00192">192</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

<p>Referenced by <a class="el" href="../../d1/d06/observation_manager_8h_source.html#l00228">tudat::observation_models::ObservationManager&lt; ObservationSize, ObservationScalarType, TimeType &gt;::computeObservationsWithPartials()</a>, and <a class="el" href="../../d0/dc9/observation_simulator_8h_source.html#l00077">tudat::observation_models::simulateObservationsWithCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ae084b530a39126d9f71b9564a1795c4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; tudat::utilities::convertEigenVectorToStlVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00247">247</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

<p>Referenced by <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00174">tudat::linear_algebra::getLeastSquaresPolynomialFit()</a>.</p>

</div>
</div>
<a class="anchor" id="a6185604e1e88e807107fba0d5fcd0b81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; tudat::utilities::convertStlVectorToEigenVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>stlVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00260">260</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

<p>Referenced by <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00174">tudat::linear_algebra::getLeastSquaresPolynomialFit()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4a4a66c9bde0984a58a3dc292d9213f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Argument &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Argument &gt; tudat::utilities::addScalarToVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Argument &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to add a double to all entries in an STL vector (addition of a double must be defined for Argument type). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector to which a double is to be added. </td></tr>
    <tr><td class="paramname">scalar</td><td>Value that is to be added to vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New vector with scalar added to all entries of input vector. </dd></dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00278">278</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a class="anchor" id="a76098cf72d99535ce14d506f507c2ed5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , int NumberOfDimensions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tudat::utilities::copyMultiArray </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; S, NumberOfDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrayToCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::multi_array&lt; S, NumberOfDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>targetArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to copy a multi-array into another multi-array, resizing the new multi-array accordingly </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrayToCopy</td><td>Multi-array that is to be copied </td></tr>
    <tr><td class="paramname">targetArray</td><td>New multi-array into which arrayToCopy is to be copied (returned by reference). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00302">302</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae55fb61a3bac2792775a0dad47b26e61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int NumberOfDimensions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::multi_array&lt; double ,NumberOfDimensions &gt;::index tudat::utilities::getMultiArrayIndex </td>
          <td>(</td>
          <td class="paramtype">const typename boost::multi_array&lt; double, NumberOfDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>requestedElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short int&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get index in nth direction of pointer to single entry in multi-array of doubles </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiArray</td><td>Multi-array for which the index is to be retrieved </td></tr>
    <tr><td class="paramname">requestedElement</td><td>Pointer to element for which index is to be retrieved </td></tr>
    <tr><td class="paramname">direction</td><td>Dimension of multi-array for which index is to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index in nth direction of pointer to single entry in multi-array of doubles </dd></dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00321">321</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

<p>References <a class="el" href="../../de/da5/utilities_8cpp_source.html#l00020">getMultiArrayIndexArray()</a>.</p>

</div>
</div>
<a class="anchor" id="a855f3e9a1ac6f189ecb64eca19bc1c76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; S &gt; tudat::utilities::createVectorFromVectorOfPairFirsts </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; S, T &gt; &gt;&#160;</td>
          <td class="paramname"><em>inputVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00362">362</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6cda666d038748d59988f002cdad36d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T tudat::utilities::evaluateFunctionWithoutInputArgumentDependency </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; T() &gt;&#160;</td>
          <td class="paramname"><em>inputFreeFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S&#160;</td>
          <td class="paramname"><em>dummyInput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00374">374</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a class="anchor" id="a93cdd935427a4cca8218aae7e2d6e408"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; tudat::utilities::getSortOrderOfVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>unsortedVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to get the order in which the input vector would be sorted (in ascending order). Example: for inout vector (5,2,6,7,4,0), output would be (5,1,4,0,2,3). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unsortedVector</td><td>Vector of which the sort order is to be determined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Order in which the input vector would be sorted (in ascending order) </dd></dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00387">387</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

<p>References <a class="el" href="../../de/df0/utilities_8h_source.html#l00453">getSortOrderOfVectorAndSortedVector()</a>.</p>

</div>
</div>
<a class="anchor" id="ae625adfdbd740bfdf4c5843bd0c4e414"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorArgument , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; VectorArgument &gt; tudat::utilities::createVectorFromMultiMapValues </td>
          <td>(</td>
          <td class="paramtype">const std::multimap&lt; KeyType, VectorArgument &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to create a vector from the values of a multimap. The output vector is in the order of the multimap entries, i.e. as provided by a forward iterator. The multimap keys are not used for the return vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputMap</td><td>Original multimap from which the vector is to be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector created from the multimap values </dd></dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00400">400</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

<p>Referenced by <a class="el" href="../../de/df0/utilities_8h_source.html#l00453">getSortOrderOfVectorAndSortedVector()</a>.</p>

</div>
</div>
<a class="anchor" id="a296cc0b23594eca7a78a8500ee568af6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorArgument , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; KeyType &gt; tudat::utilities::createVectorFromMultiMapKeys </td>
          <td>(</td>
          <td class="paramtype">const std::multimap&lt; KeyType, VectorArgument &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to create a vector from the keys of a multimap. The output vector is in the order of the multimap entries, i.e. as provided by a forward iterator. The multimap values are not used for the return vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputMap</td><td>Original multimap from which the vector is to be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector created from the multimap keys </dd></dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00427">427</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

<p>Referenced by <a class="el" href="../../de/df0/utilities_8h_source.html#l00453">getSortOrderOfVectorAndSortedVector()</a>.</p>

</div>
</div>
<a class="anchor" id="a553717c9b01a377e5fbb47f9f3b596d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; T &gt; &gt; tudat::utilities::getSortOrderOfVectorAndSortedVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>unsortedVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to get sorted vector of an input vector, as well as the order in which this input has been be sorted (ascending)). Example: for inout vector (5,2,6,7,4,0), output would be [(5,1,4,0,2,3), (0,2,4,5,6,7)]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unsortedVector</td><td>Vector that is to be sorted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Parit, with first: order in which the input vector is sorted (in ascending order), second: sorted input vector </dd></dl>

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00453">453</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

<p>References <a class="el" href="../../de/df0/utilities_8h_source.html#l00427">createVectorFromMultiMapKeys()</a>, and <a class="el" href="../../de/df0/utilities_8h_source.html#l00400">createVectorFromMultiMapValues()</a>.</p>

<p>Referenced by <a class="el" href="../../de/df0/utilities_8h_source.html#l00387">getSortOrderOfVector()</a>, and <a class="el" href="../../dc/d42/pod_processing_8h_source.html#l00199">tudat::simulation_setup::getTimeOrderedInformationMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c3729d39dbee0d760df4a34697f77d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tudat::utilities::doStlVectorContentsMatch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectorA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectorB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00465">465</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

<p>Referenced by <a class="el" href="../../de/db0/gravity_field_variations_8cpp_source.html#l00262">tudat::gravitation::GravityFieldVariationsSet::getDirectTidalGravityFieldVariation()</a>.</p>

</div>
</div>
<a class="anchor" id="acad8ef028c0ca96f764a938016c7a01b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapKey , typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; MapKey, Eigen::Array&lt; ScalarType, Eigen::Dynamic, 1 &gt; &gt; tudat::utilities::convertSTLVectorMapToEigenVectorMap </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; MapKey, std::vector&lt; ScalarType &gt; &gt;&#160;</td>
          <td class="paramname"><em>stlVectorMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../de/df0/utilities_8h_source.html#l00490">490</a> of file <a class="el" href="../../de/df0/utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 27 2017 09:33:03 for Tudat by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
