<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tudat: tudat::linear_algebra Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tudat
   </div>
   <div id="projectbrief">TU Delft astrodynamics toolbox</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d6/d6d/namespacetudat.html">tudat</a></li><li class="navelem"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html">linear_algebra</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tudat::linear_algebra Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afc4b3900b9047d7dbbf8ebacb154302e"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#afc4b3900b9047d7dbbf8ebacb154302e">calculateInverseOfUpdatedCovarianceMatrix</a> (const Eigen::MatrixXd &amp;informationMatrix, const Eigen::VectorXd &amp;diagonalOfWeightMatrix, const Eigen::MatrixXd &amp;inverseOfAPrioriCovarianceMatrix)</td></tr>
<tr class="memdesc:afc4b3900b9047d7dbbf8ebacb154302e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute inverse of covariance matrix at current iteration, including influence of a priori information.  <a href="#afc4b3900b9047d7dbbf8ebacb154302e">More...</a><br /></td></tr>
<tr class="separator:afc4b3900b9047d7dbbf8ebacb154302e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95569c28d85f3d065dc2ee70fa1fd3c"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#af95569c28d85f3d065dc2ee70fa1fd3c">calculateInverseOfUpdatedCovarianceMatrix</a> (const Eigen::MatrixXd &amp;informationMatrix, const Eigen::VectorXd &amp;diagonalOfWeightMatrix)</td></tr>
<tr class="memdesc:af95569c28d85f3d065dc2ee70fa1fd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute inverse of covariance matrix at current iteration.  <a href="#af95569c28d85f3d065dc2ee70fa1fd3c">More...</a><br /></td></tr>
<tr class="separator:af95569c28d85f3d065dc2ee70fa1fd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8b0868a1d5f1c1daf8a243c7f9e840"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#a4a8b0868a1d5f1c1daf8a243c7f9e840">calculatePartialOfNormalizedVector</a> (const Eigen::Matrix3d &amp;partialOfUnnormalizedVector, const Eigen::Vector3d &amp;unnormalizedVector)</td></tr>
<tr class="memdesc:a4a8b0868a1d5f1c1daf8a243c7f9e840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the jacobian of a normalized vector, from the partial of the unnormalized vector.  <a href="#a4a8b0868a1d5f1c1daf8a243c7f9e840">More...</a><br /></td></tr>
<tr class="separator:a4a8b0868a1d5f1c1daf8a243c7f9e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705ee32706d9214b89d2d4a155cba1d7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#a705ee32706d9214b89d2d4a155cba1d7">computeAngleBetweenVectors</a> (const Eigen::VectorXd &amp;vector0, const Eigen::VectorXd &amp;vector1)</td></tr>
<tr class="memdesc:a705ee32706d9214b89d2d4a155cba1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute angle between two vectors.  <a href="#a705ee32706d9214b89d2d4a155cba1d7">More...</a><br /></td></tr>
<tr class="separator:a705ee32706d9214b89d2d4a155cba1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8adc85575264c7d94027be05ec3cff7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#ad8adc85575264c7d94027be05ec3cff7">computeCosineOfAngleBetweenVectors</a> (const Eigen::VectorXd &amp;vector0, const Eigen::VectorXd &amp;vector1)</td></tr>
<tr class="memdesc:ad8adc85575264c7d94027be05ec3cff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cosine of the angle between two vectors.  <a href="#ad8adc85575264c7d94027be05ec3cff7">More...</a><br /></td></tr>
<tr class="separator:ad8adc85575264c7d94027be05ec3cff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b510b13c3fda9293ac7e4739d3fae2b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#a4b510b13c3fda9293ac7e4739d3fae2b">computeNormOfVectorDifference</a> (const Eigen::Vector3d &amp;vector0, const Eigen::Vector3d &amp;vector1)</td></tr>
<tr class="memdesc:a4b510b13c3fda9293ac7e4739d3fae2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes norm of the the difference between two 3d vectors.  <a href="#a4b510b13c3fda9293ac7e4739d3fae2b">More...</a><br /></td></tr>
<tr class="separator:a4b510b13c3fda9293ac7e4739d3fae2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1b257b4acc43b8efd27ec4adfb81d2"><td class="memTemplParams" colspan="2">template&lt;int VectorSize&gt; </td></tr>
<tr class="memitem:aec1b257b4acc43b8efd27ec4adfb81d2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, VectorSize, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#aec1b257b4acc43b8efd27ec4adfb81d2">computeVectorDifference</a> (const Eigen::Matrix&lt; double, VectorSize, 1 &gt; &amp;vector0, const Eigen::Matrix&lt; double, VectorSize, 1 &gt; &amp;vector1)</td></tr>
<tr class="memdesc:aec1b257b4acc43b8efd27ec4adfb81d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference between two 3d vectors.  <a href="#aec1b257b4acc43b8efd27ec4adfb81d2">More...</a><br /></td></tr>
<tr class="separator:aec1b257b4acc43b8efd27ec4adfb81d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2ea62e24ce2736c5dbc2be74358f60"><td class="memItemLeft" align="right" valign="top">Eigen::Vector4d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#aab2ea62e24ce2736c5dbc2be74358f60">convertQuaternionToVectorFormat</a> (const Eigen::Quaterniond &amp;quaternion)</td></tr>
<tr class="memdesc:aab2ea62e24ce2736c5dbc2be74358f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to put a quaternion in 'vector format', e.g. a Vector4d with entries (w,x,y,z) of the quaternion.  <a href="#aab2ea62e24ce2736c5dbc2be74358f60">More...</a><br /></td></tr>
<tr class="separator:aab2ea62e24ce2736c5dbc2be74358f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b95fdd947ebc4bc590669ee4e400a1"><td class="memItemLeft" align="right" valign="top">Eigen::Quaterniond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#ad5b95fdd947ebc4bc590669ee4e400a1">convertVectorToQuaternionFormat</a> (const Eigen::Vector4d &amp;vector)</td></tr>
<tr class="memdesc:ad5b95fdd947ebc4bc590669ee4e400a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to put a vector in 'quaternion format', i.e. a Quaterniond.  <a href="#ad5b95fdd947ebc4bc590669ee4e400a1">More...</a><br /></td></tr>
<tr class="separator:ad5b95fdd947ebc4bc590669ee4e400a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e95e3d7af61753bf76023829ce39c7e"><td class="memTemplParams" colspan="2">template&lt;typename StateScalarType , int NumberOfRows, int NumberOfColumns&gt; </td></tr>
<tr class="memitem:a2e95e3d7af61753bf76023829ce39c7e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#a2e95e3d7af61753bf76023829ce39c7e">doesMatrixHaveNanEntries</a> (const Eigen::Matrix&lt; StateScalarType, NumberOfRows, NumberOfColumns &gt; matrixToCheck)</td></tr>
<tr class="memdesc:a2e95e3d7af61753bf76023829ce39c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check whether an <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> Matrix has any NaN entries.  <a href="#a2e95e3d7af61753bf76023829ce39c7e">More...</a><br /></td></tr>
<tr class="separator:a2e95e3d7af61753bf76023829ce39c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092a80b83dac4a7a0bd93e9eaf115fda"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#a092a80b83dac4a7a0bd93e9eaf115fda">evaluateSecondBlockInStateVector</a> (const std::function&lt; <a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a>(const double) &gt; stateFunction, const double time)</td></tr>
<tr class="separator:a092a80b83dac4a7a0bd93e9eaf115fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1fb56bc2c52e21c8e78431ea336f21"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#adf1fb56bc2c52e21c8e78431ea336f21">flipMatrixRows</a> (Eigen::MatrixXd &amp;matrixToFlip)</td></tr>
<tr class="memdesc:adf1fb56bc2c52e21c8e78431ea336f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip matrix rows.  <a href="#adf1fb56bc2c52e21c8e78431ea336f21">More...</a><br /></td></tr>
<tr class="separator:adf1fb56bc2c52e21c8e78431ea336f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83828767cdccfbd1a5d10136406ce62"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#ad83828767cdccfbd1a5d10136406ce62">getConditionNumberOfDecomposedMatrix</a> (const Eigen::JacobiSVD&lt; Eigen::MatrixXd &gt; &amp;singularValueDecomposition)</td></tr>
<tr class="memdesc:ad83828767cdccfbd1a5d10136406ce62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get condition number of matrix from SVD decomposition.  <a href="#ad83828767cdccfbd1a5d10136406ce62">More...</a><br /></td></tr>
<tr class="separator:ad83828767cdccfbd1a5d10136406ce62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2cb6212b6d36217e989a039ca4706a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#a9e2cb6212b6d36217e989a039ca4706a">getConditionNumberOfInformationMatrix</a> (const Eigen::MatrixXd informationMatrix)</td></tr>
<tr class="memdesc:a9e2cb6212b6d36217e989a039ca4706a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get condition number of matrix (using SVD decomposition)  <a href="#a9e2cb6212b6d36217e989a039ca4706a">More...</a><br /></td></tr>
<tr class="separator:a9e2cb6212b6d36217e989a039ca4706a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7f7990f96259841bedd69af9943725"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#a6d7f7990f96259841bedd69af9943725">getCrossProductMatrix</a> (const Eigen::Vector3d &amp;vector)</td></tr>
<tr class="memdesc:a6d7f7990f96259841bedd69af9943725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns that 'cross-product matrix'.  <a href="#a6d7f7990f96259841bedd69af9943725">More...</a><br /></td></tr>
<tr class="separator:a6d7f7990f96259841bedd69af9943725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686f905ec8969949325baa80d21ce636"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#a686f905ec8969949325baa80d21ce636">getLeastSquaresPolynomialFit</a> (const Eigen::VectorXd &amp;independentValues, const Eigen::VectorXd &amp;dependentValues, const std::vector&lt; double &gt; &amp;polynomialPowers)</td></tr>
<tr class="memdesc:a686f905ec8969949325baa80d21ce636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to fit a univariate polynomial through a set of data.  <a href="#a686f905ec8969949325baa80d21ce636">More...</a><br /></td></tr>
<tr class="separator:a686f905ec8969949325baa80d21ce636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9205397a39a606384a8236dda60384b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#ae9205397a39a606384a8236dda60384b">getLeastSquaresPolynomialFit</a> (const std::map&lt; double, double &gt; &amp;independentDependentValueMap, const std::vector&lt; double &gt; &amp;polynomialPowers)</td></tr>
<tr class="memdesc:ae9205397a39a606384a8236dda60384b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to fit a univariate polynomial through a set of data.  <a href="#ae9205397a39a606384a8236dda60384b">More...</a><br /></td></tr>
<tr class="separator:ae9205397a39a606384a8236dda60384b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac84507727e00166354321dfb26402be"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#aac84507727e00166354321dfb26402be">getVectorEntryRootMeanSquare</a> (const Eigen::VectorXd &amp;inputVector)</td></tr>
<tr class="memdesc:aac84507727e00166354321dfb26402be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the root mean square value of the entries in an <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> vector.  <a href="#aac84507727e00166354321dfb26402be">More...</a><br /></td></tr>
<tr class="separator:aac84507727e00166354321dfb26402be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83191d4a9df7d3b146350cc9dd0ddb3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#ae83191d4a9df7d3b146350cc9dd0ddb3">getVectorNorm</a> (const Eigen::Vector3d &amp;vector)</td></tr>
<tr class="memdesc:ae83191d4a9df7d3b146350cc9dd0ddb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the norm of a 3d vector.  <a href="#ae83191d4a9df7d3b146350cc9dd0ddb3">More...</a><br /></td></tr>
<tr class="separator:ae83191d4a9df7d3b146350cc9dd0ddb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0150ca2178df1f4c93d658b38c2dcb7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#ae0150ca2178df1f4c93d658b38c2dcb7">getVectorNormFromFunction</a> (const std::function&lt; Eigen::Vector3d() &gt; vectorFunction)</td></tr>
<tr class="memdesc:ae0150ca2178df1f4c93d658b38c2dcb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the norm of a 3d vector from a vector-returning function.  <a href="#ae0150ca2178df1f4c93d658b38c2dcb7">More...</a><br /></td></tr>
<tr class="separator:ae0150ca2178df1f4c93d658b38c2dcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272cec72561232bb0ee4527da6dc5f87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#a272cec72561232bb0ee4527da6dc5f87">invertQuaternion</a> (Eigen::Vector4d &amp;quaternionVector)</td></tr>
<tr class="memdesc:a272cec72561232bb0ee4527da6dc5f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to invert a quaternion.  <a href="#a272cec72561232bb0ee4527da6dc5f87">More...</a><br /></td></tr>
<tr class="separator:a272cec72561232bb0ee4527da6dc5f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac387020653fb44716e6ce7f111c108d"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#aac387020653fb44716e6ce7f111c108d">multiplyInformationMatrixByDiagonalWeightMatrix</a> (const Eigen::MatrixXd &amp;informationMatrix, const Eigen::VectorXd &amp;diagonalOfWeightMatrix)</td></tr>
<tr class="memdesc:aac387020653fb44716e6ce7f111c108d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to multiply information matrix by diagonal weights matrix.  <a href="#aac387020653fb44716e6ce7f111c108d">More...</a><br /></td></tr>
<tr class="separator:aac387020653fb44716e6ce7f111c108d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b952e298602eeaffb4e382094c34a6"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#aa8b952e298602eeaffb4e382094c34a6">nonLinearLeastSquaresFit</a> (const std::function&lt; std::pair&lt; Eigen::VectorXd, Eigen::MatrixXd &gt;(const Eigen::VectorXd &amp;) &gt; &amp;observationAndJacobianFunctions, const Eigen::VectorXd &amp;initialEstimate, const Eigen::VectorXd &amp;actualObservations, const double initialScaling, const double convergenceTolerance, const unsigned int maximumNumberOfIterations)</td></tr>
<tr class="memdesc:aa8b952e298602eeaffb4e382094c34a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to perform a non-linear least squares estimation with the Levenberg-Marquardt method.  <a href="#aa8b952e298602eeaffb4e382094c34a6">More...</a><br /></td></tr>
<tr class="separator:aa8b952e298602eeaffb4e382094c34a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea037dc2b1d98113041631484ec343dc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::VectorXd, Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#aea037dc2b1d98113041631484ec343dc">performLeastSquaresAdjustmentFromInformationMatrix</a> (const Eigen::MatrixXd &amp;informationMatrix, const Eigen::VectorXd &amp;observationResiduals, const Eigen::VectorXd &amp;diagonalOfWeightMatrix, const Eigen::MatrixXd &amp;inverseOfAPrioriCovarianceMatrix, const bool checkConditionNumber=1, const double maximumAllowedConditionNumber=1.0E8)</td></tr>
<tr class="memdesc:aea037dc2b1d98113041631484ec343dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to perform an iteration least squares estimation from information matrix, weights and residuals and a priori information, as is typically done in orbit determination.  <a href="#aea037dc2b1d98113041631484ec343dc">More...</a><br /></td></tr>
<tr class="separator:aea037dc2b1d98113041631484ec343dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e177dad478f88e82d9cb2a710a30ac"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::VectorXd, Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#af0e177dad478f88e82d9cb2a710a30ac">performLeastSquaresAdjustmentFromInformationMatrix</a> (const Eigen::MatrixXd &amp;informationMatrix, const Eigen::VectorXd &amp;observationResiduals, const Eigen::VectorXd &amp;diagonalOfWeightMatrix, const bool checkConditionNumber, const double maximumAllowedConditionNumber)</td></tr>
<tr class="memdesc:af0e177dad478f88e82d9cb2a710a30ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to perform an iteration least squares estimation from information matrix, weights and residuals.  <a href="#af0e177dad478f88e82d9cb2a710a30ac">More...</a><br /></td></tr>
<tr class="separator:af0e177dad478f88e82d9cb2a710a30ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457dcce8d21fd25ca761fd2985f1968f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::VectorXd, Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#a457dcce8d21fd25ca761fd2985f1968f">performLeastSquaresAdjustmentFromInformationMatrix</a> (const Eigen::MatrixXd &amp;informationMatrix, const Eigen::VectorXd &amp;observationResiduals, const bool checkConditionNumber, const double maximumAllowedConditionNumber)</td></tr>
<tr class="memdesc:a457dcce8d21fd25ca761fd2985f1968f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to perform an iteration of least squares estimation from information matrix and residuals.  <a href="#a457dcce8d21fd25ca761fd2985f1968f">More...</a><br /></td></tr>
<tr class="separator:a457dcce8d21fd25ca761fd2985f1968f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb8204b4d9c0148ca38f9a6650e6bf4"><td class="memItemLeft" align="right" valign="top">Eigen::Vector4d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#a5fb8204b4d9c0148ca38f9a6650e6bf4">quaternionProduct</a> (const Eigen::Vector4d &amp;firstQuaternion, const Eigen::Vector4d &amp;secondQuaternion)</td></tr>
<tr class="memdesc:a5fb8204b4d9c0148ca38f9a6650e6bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to take the product of two quaternions.  <a href="#a5fb8204b4d9c0148ca38f9a6650e6bf4">More...</a><br /></td></tr>
<tr class="separator:a5fb8204b4d9c0148ca38f9a6650e6bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffc8465e641ddbac2315e4a9aae2b97"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/namespacetudat_1_1linear__algebra.html#a9ffc8465e641ddbac2315e4a9aae2b97">solveSystemOfEquationsWithSvd</a> (const Eigen::MatrixXd matrixToInvert, const Eigen::VectorXd rightHandSideVector, const bool checkConditionNumber, const double maximumAllowedConditionNumber)</td></tr>
<tr class="memdesc:a9ffc8465e641ddbac2315e4a9aae2b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve system of equations with SVD decomposition, checking condition number in the process.  <a href="#a9ffc8465e641ddbac2315e4a9aae2b97">More...</a><br /></td></tr>
<tr class="separator:a9ffc8465e641ddbac2315e4a9aae2b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9e2cb6212b6d36217e989a039ca4706a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2cb6212b6d36217e989a039ca4706a">&#9670;&nbsp;</a></span>getConditionNumberOfInformationMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::linear_algebra::getConditionNumberOfInformationMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>informationMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to get condition number of matrix (using SVD decomposition) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">informationMatrix</td><td>Matrix for which condition number is to be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Condition number of matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00027">27</a> of file <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html">leastSquaresEstimation.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00034">getConditionNumberOfDecomposedMatrix()</a>.</p>

</div>
</div>
<a id="ad83828767cdccfbd1a5d10136406ce62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83828767cdccfbd1a5d10136406ce62">&#9670;&nbsp;</a></span>getConditionNumberOfDecomposedMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::linear_algebra::getConditionNumberOfDecomposedMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::JacobiSVD&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>singularValueDecomposition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to get condition number of matrix from SVD decomposition </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">singularValueDecomposition</td><td>SVD decomposition of matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Condition number of matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00034">34</a> of file <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html">leastSquaresEstimation.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00027">getConditionNumberOfInformationMatrix()</a>, and <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00041">solveSystemOfEquationsWithSvd()</a>.</p>

</div>
</div>
<a id="a9ffc8465e641ddbac2315e4a9aae2b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ffc8465e641ddbac2315e4a9aae2b97">&#9670;&nbsp;</a></span>solveSystemOfEquationsWithSvd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd tudat::linear_algebra::solveSystemOfEquationsWithSvd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>matrixToInvert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd&#160;</td>
          <td class="paramname"><em>rightHandSideVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>checkConditionNumber</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maximumAllowedConditionNumber</em> = <code>1.0E-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Solve system of equations with SVD decomposition, checking condition number in the process. This function solves A*x = b for the vector x. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrixToInvert</td><td>Matrix A that is to be inverted to solve the equation </td></tr>
    <tr><td class="paramname">rightHandSideVector</td><td>Vector on the righthandside of the matrix equation that is to be solved </td></tr>
    <tr><td class="paramname">checkConditionNumber</td><td>Boolean to denote whether the condition number is checked when estimating (warning is printed when value exceeds maximumAllowedConditionNumber) </td></tr>
    <tr><td class="paramname">maximumAllowedConditionNumber</td><td>Maximum value of the condition number of the covariance matrix that is allowed (warning printed when exceeded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Solution x of matrix equation A*x=b </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00041">41</a> of file <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html">leastSquaresEstimation.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00034">getConditionNumberOfDecomposedMatrix()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00098">performLeastSquaresAdjustmentFromInformationMatrix()</a>.</p>

</div>
</div>
<a id="aac387020653fb44716e6ce7f111c108d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac387020653fb44716e6ce7f111c108d">&#9670;&nbsp;</a></span>multiplyInformationMatrixByDiagonalWeightMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd tudat::linear_algebra::multiplyInformationMatrixByDiagonalWeightMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>informationMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>diagonalOfWeightMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to multiply information matrix by diagonal weights matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">informationMatrix</td><td>Matrix containing partial derivatives of observations (rows) w.r.t. estimated parameters (columns) </td></tr>
    <tr><td class="paramname">diagonalOfWeightMatrix</td><td>Diagonal of observation weights matrix (assumes all weights to be uncorrelated) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>informationMatrix, premultiplied by square matrix with diagonalOfWeightMatrix as diagonal elements </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00061">61</a> of file <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html">leastSquaresEstimation.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00077">calculateInverseOfUpdatedCovarianceMatrix()</a>.</p>

</div>
</div>
<a id="afc4b3900b9047d7dbbf8ebacb154302e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4b3900b9047d7dbbf8ebacb154302e">&#9670;&nbsp;</a></span>calculateInverseOfUpdatedCovarianceMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd tudat::linear_algebra::calculateInverseOfUpdatedCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>informationMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>diagonalOfWeightMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>inverseOfAPrioriCovarianceMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to compute inverse of covariance matrix at current iteration, including influence of a priori information </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">informationMatrix</td><td>Matrix containing partial derivatives of observations (rows) w.r.t. estimated parameters (columns) </td></tr>
    <tr><td class="paramname">diagonalOfWeightMatrix</td><td>Diagonal of observation weights matrix (assumes all weights to be uncorrelated) </td></tr>
    <tr><td class="paramname">inverseOfAPrioriCovarianceMatrix</td><td>Inverse of a priori covariance matrix (warning printed when exceeded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse of covariance matrix at current iteration </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00077">77</a> of file <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html">leastSquaresEstimation.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00061">multiplyInformationMatrixByDiagonalWeightMatrix()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d42/pod_processing_8h_source.html#l00271">tudat::simulation_setup::calculateCovarianceMatrixAsFunctionOfTime()</a>, <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00087">calculateInverseOfUpdatedCovarianceMatrix()</a>, and <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00098">performLeastSquaresAdjustmentFromInformationMatrix()</a>.</p>

</div>
</div>
<a id="af95569c28d85f3d065dc2ee70fa1fd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95569c28d85f3d065dc2ee70fa1fd3c">&#9670;&nbsp;</a></span>calculateInverseOfUpdatedCovarianceMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd tudat::linear_algebra::calculateInverseOfUpdatedCovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>informationMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>diagonalOfWeightMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to compute inverse of covariance matrix at current iteration </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">informationMatrix</td><td>Matrix containing partial derivatives of observations (rows) w.r.t. estimated parameters (columns) </td></tr>
    <tr><td class="paramname">diagonalOfWeightMatrix</td><td>Diagonal of observation weights matrix (assumes all weights to be uncorrelated) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse of covariance matrix at current iteration </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00087">87</a> of file <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html">leastSquaresEstimation.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00077">calculateInverseOfUpdatedCovarianceMatrix()</a>.</p>

</div>
</div>
<a id="aea037dc2b1d98113041631484ec343dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea037dc2b1d98113041631484ec343dc">&#9670;&nbsp;</a></span>performLeastSquaresAdjustmentFromInformationMatrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::VectorXd, Eigen::MatrixXd &gt; tudat::linear_algebra::performLeastSquaresAdjustmentFromInformationMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>informationMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>observationResiduals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>diagonalOfWeightMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>inverseOfAPrioriCovarianceMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>checkConditionNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maximumAllowedConditionNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to perform an iteration least squares estimation from information matrix, weights and residuals and a priori information</p>
<p class="">Function to perform an iteration least squares estimation from information matrix, weights and residuals and a priori information</p>
<p class="">This function also takes an inverse if the a priori covariance matrix to constrain/stabilize the inversion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">informationMatrix</td><td>Matrix containing partial derivatives of observations (rows) w.r.t. estimated parameters (columns) </td></tr>
    <tr><td class="paramname">observationResiduals</td><td>Difference between measured and simulated observations </td></tr>
    <tr><td class="paramname">diagonalOfWeightMatrix</td><td>Diagonal of observation weights matrix (assumes all weights to be uncorrelated) </td></tr>
    <tr><td class="paramname">inverseOfAPrioriCovarianceMatrix</td><td>Inverse of a priori covariance matrix (warning printed when exceeded) </td></tr>
    <tr><td class="paramname">checkConditionNumber</td><td>Boolean to denote whether the condition number is checked when estimating (warning is printed when value exceeds maximumAllowedConditionNumber) </td></tr>
    <tr><td class="paramname">maximumAllowedConditionNumber</td><td>Maximum value of the condition number of the covariance matrix that is allowed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing: (first: parameter adjustment, second: inverse covariance) </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00098">98</a> of file <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html">leastSquaresEstimation.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00077">calculateInverseOfUpdatedCovarianceMatrix()</a>, and <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00041">solveSystemOfEquationsWithSvd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/de2/orbit_determination_manager_8h_source.html#l00461">tudat::simulation_setup::OrbitDeterminationManager&lt; ObservationScalarType, TimeType, std::enable_if&lt; is_state_scalar_and_time_type&lt; ObservationScalarType, TimeType &gt;::value, int &gt;::type &gt;::estimateParameters()</a>, <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00142">getLeastSquaresPolynomialFit()</a>, <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00182">nonLinearLeastSquaresFit()</a>, and <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00116">performLeastSquaresAdjustmentFromInformationMatrix()</a>.</p>

</div>
</div>
<a id="af0e177dad478f88e82d9cb2a710a30ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e177dad478f88e82d9cb2a710a30ac">&#9670;&nbsp;</a></span>performLeastSquaresAdjustmentFromInformationMatrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::VectorXd, Eigen::MatrixXd &gt; tudat::linear_algebra::performLeastSquaresAdjustmentFromInformationMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>informationMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>observationResiduals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>diagonalOfWeightMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>checkConditionNumber</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maximumAllowedConditionNumber</em> = <code>1.0E8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to perform an iteration of least squares estimation from information matrix, weights and residuals.</p>
<p class="">Function to perform an iteration of least squares estimation from information matrix, weights and residuals, as is typically done in orbit determination </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">informationMatrix</td><td>Matrix containing partial derivatives of observations (rows) w.r.t. estimated parameters (columns) </td></tr>
    <tr><td class="paramname">observationResiduals</td><td>Difference between measured and simulated observations </td></tr>
    <tr><td class="paramname">diagonalOfWeightMatrix</td><td>Diagonal of observation weights matrix (assumes all weights to be uncorrelated) </td></tr>
    <tr><td class="paramname">checkConditionNumber</td><td>Boolean to denote whether the condition number is checked when estimating (warning is printed when value exceeds maximumAllowedConditionNumber) </td></tr>
    <tr><td class="paramname">maximumAllowedConditionNumber</td><td>Maximum value of the condition number of the covariance matrix that is allowed (warning printed when exceeded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing: (first: parameter adjustment, second: inverse covariance) </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00116">116</a> of file <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html">leastSquaresEstimation.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00098">performLeastSquaresAdjustmentFromInformationMatrix()</a>.</p>

</div>
</div>
<a id="a457dcce8d21fd25ca761fd2985f1968f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457dcce8d21fd25ca761fd2985f1968f">&#9670;&nbsp;</a></span>performLeastSquaresAdjustmentFromInformationMatrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::VectorXd, Eigen::MatrixXd &gt; tudat::linear_algebra::performLeastSquaresAdjustmentFromInformationMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>informationMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>observationResiduals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>checkConditionNumber</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maximumAllowedConditionNumber</em> = <code>1.0E8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to perform an iteration of least squares estimation from information matrix and residuals, with all weights fixed to 1.0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">informationMatrix</td><td>Matrix containing partial derivatives of observations (rows) w.r.t. estimated parameters (columns) </td></tr>
    <tr><td class="paramname">observationResiduals</td><td>Difference between measured and simulated observations </td></tr>
    <tr><td class="paramname">checkConditionNumber</td><td>Boolean to denote whether the condition number is checked when estimating (warning is printed when value exceeds maximumAllowedConditionNumber) </td></tr>
    <tr><td class="paramname">maximumAllowedConditionNumber</td><td>Maximum value of the condition number of the covariance matrix that is allowed (warning printed when exceeded) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing: (first: parameter adjustment, second: inverse covariance) </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00130">130</a> of file <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html">leastSquaresEstimation.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00098">performLeastSquaresAdjustmentFromInformationMatrix()</a>.</p>

</div>
</div>
<a id="a686f905ec8969949325baa80d21ce636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686f905ec8969949325baa80d21ce636">&#9670;&nbsp;</a></span>getLeastSquaresPolynomialFit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd tudat::linear_algebra::getLeastSquaresPolynomialFit </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>independentValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dependentValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>polynomialPowers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to fit a univariate polynomial through a set of data. User must provide independent variables and observations (dependent variables), as well as a list of polynomial powers for which the coefficients are to be estimated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">independentValues</td><td>Independent variables of input data (e.g. time for observations as a function fo time). This variable becomes the polynomial argument. </td></tr>
    <tr><td class="paramname">dependentValues</td><td>Observations through which the polynomial is to be fitted, with entries defined at the corresponding entries of independentValues </td></tr>
    <tr><td class="paramname">polynomialPowers</td><td>List of powers of indepent variables for which coefficients are to be estimated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Coefficients of the polynomial powers, as estimated from the input data (in same order as polynomialPowers). </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00142">142</a> of file <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html">leastSquaresEstimation.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00098">performLeastSquaresAdjustmentFromInformationMatrix()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00168">getLeastSquaresPolynomialFit()</a>.</p>

</div>
</div>
<a id="ae9205397a39a606384a8236dda60384b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9205397a39a606384a8236dda60384b">&#9670;&nbsp;</a></span>getLeastSquaresPolynomialFit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; tudat::linear_algebra::getLeastSquaresPolynomialFit </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; double, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>independentDependentValueMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>polynomialPowers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to fit a univariate polynomial through a set of data. User must provide independent variables and observations (dependent variables), as well as a list of polynomial powers for which the coefficients are to be estimated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">independentDependentValueMap</td><td>Map with key: independent variables of input data (e.g. time for observations as a function fo time), this variable becomes the polynomial argument. Map value: Observations through which the polynomial is to be fitted. </td></tr>
    <tr><td class="paramname">polynomialPowers</td><td>List of powers of indepent variables for which coefficients are to be estimated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Coefficients of the polynomial powers, as estimated from the input data (in same order as polynomialPowers). </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00168">168</a> of file <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html">leastSquaresEstimation.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00312">tudat::utilities::convertEigenVectorToStlVector()</a>, <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00325">tudat::utilities::convertStlVectorToEigenVector()</a>, <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00100">tudat::utilities::createVectorFromMapKeys()</a>, <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00075">tudat::utilities::createVectorFromMapValues()</a>, and <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00142">getLeastSquaresPolynomialFit()</a>.</p>

</div>
</div>
<a id="aa8b952e298602eeaffb4e382094c34a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b952e298602eeaffb4e382094c34a6">&#9670;&nbsp;</a></span>nonLinearLeastSquaresFit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd tudat::linear_algebra::nonLinearLeastSquaresFit </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::pair&lt; Eigen::VectorXd, Eigen::MatrixXd &gt;(const Eigen::VectorXd &amp;) &gt; &amp;&#160;</td>
          <td class="paramname"><em>observationAndJacobianFunctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>initialEstimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>actualObservations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>initialScaling</em> = <code>1.0e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>convergenceTolerance</em> = <code>1.0e-8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>maximumNumberOfIterations</em> = <code>25</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to perform a non-linear least squares estimation. The non-linear least squares method is an iterative process, which uses the information from the actual and estimated observations, to estimate the model parameters, with the aid of a design matrix. The initial estimate of the model parameters is updated every iteration with the result of the least squares equation. The iterative process is halted whenever the norm of the update is below the user-provided threshold or when the maximum number of iterations is reached. The method used in this application is the Levenberg-Marquardt method, which uses a damping parameter <img class="formulaInl" alt="$ \lambda $" src="../../form_120.png"/> to make the iterative process more stable and accurate. The reference for this implementation is (Madsen, K., et al.). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observationAndJacobianFunctions</td><td>Function returning a pair of expected observations and Jacobian of the observation function w.r.t. the model parameters (i.e., the design matrix), where the input is the current estimate of the model parameters. </td></tr>
    <tr><td class="paramname">initialEstimate</td><td>Initial estimate of the model parameters. </td></tr>
    <tr><td class="paramname">actualObservations</td><td>Vector containing the actual observations that need to be fitted by the model. </td></tr>
    <tr><td class="paramname">initialScaling</td><td>Double denoting the multiplicative factor to determine the damping parameter during the first iteration. </td></tr>
    <tr><td class="paramname">convergenceTolerance</td><td>Double denoting the convergence criterion for the norm of the update vector. </td></tr>
    <tr><td class="paramname">maximumNumberOfIterations</td><td>Integer denoting the maximum number of iterations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optimal value of the model parameters that minimize the least squares error between expected and actual observations. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00182">182</a> of file <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html">leastSquaresEstimation.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00098">performLeastSquaresAdjustmentFromInformationMatrix()</a>.</p>

</div>
</div>
<a id="aab2ea62e24ce2736c5dbc2be74358f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2ea62e24ce2736c5dbc2be74358f60">&#9670;&nbsp;</a></span>convertQuaternionToVectorFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector4d tudat::linear_algebra::convertQuaternionToVectorFormat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaterniond &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to put a quaternion in 'vector format', e.g. a Vector4d with entries (w,x,y,z) of the quaternion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quaternion</td><td>Quaternion that is to be put into vector format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector format of input quaternion. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00026">26</a> of file <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html">linearAlgebra.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d8c/_simulation_setup_2_environment_setup_2body_8h_source.html#l00617">tudat::simulation_setup::Body::getCurrentRotationalState()</a>.</p>

</div>
</div>
<a id="ad5b95fdd947ebc4bc590669ee4e400a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b95fdd947ebc4bc590669ee4e400a1">&#9670;&nbsp;</a></span>convertVectorToQuaternionFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaterniond tudat::linear_algebra::convertVectorToQuaternionFormat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to put a vector in 'quaternion format', i.e. a Quaterniond. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector format of input quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Quaternion that is to be put into vector format. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00037">37</a> of file <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html">linearAlgebra.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d86/unified_state_model_quaternion_element_conversions_8cpp_source.html#l00612">tudat::orbital_element_conversions::convertUnifiedStateModelQuaternionsToCartesianElements()</a>.</p>

</div>
</div>
<a id="a5fb8204b4d9c0148ca38f9a6650e6bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb8204b4d9c0148ca38f9a6650e6bf4">&#9670;&nbsp;</a></span>quaternionProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector4d tudat::linear_algebra::quaternionProduct </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>firstQuaternion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>secondQuaternion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to take the product of two quaternions, both expressed as vectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstQuaternion</td><td>First quaternion expressed as vector. </td></tr>
    <tr><td class="paramname">secondQuaternion</td><td>Second quaternion expressed as vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of the two quaternions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00048">48</a> of file <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html">linearAlgebra.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00066">getCrossProductMatrix()</a>.</p>

</div>
</div>
<a id="a272cec72561232bb0ee4527da6dc5f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272cec72561232bb0ee4527da6dc5f87">&#9670;&nbsp;</a></span>invertQuaternion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tudat::linear_algebra::invertQuaternion </td>
          <td>(</td>
          <td class="paramtype">Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>quaternionVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to invert a quaternion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quaternionVector</td><td>Quaternion expressed as vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00060">60</a> of file <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html">linearAlgebra.cpp</a>.</p>

</div>
</div>
<a id="a6d7f7990f96259841bedd69af9943725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7f7990f96259841bedd69af9943725">&#9670;&nbsp;</a></span>getCrossProductMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix3d tudat::linear_algebra::getCrossProductMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>leftHandVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function that returns that 'cross-product matrix', i.e. for vectors a,b and c, with c = a x b, the matrix A such that c = Ab. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftHandVector</td><td>The left-multiplying vector (a in above example) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix by which to premultiply the right-multiplying vector to obtain the cross product of the two matrices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00066">66</a> of file <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html">linearAlgebra.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/de5/rotational_motion_modified_rodrigues_parameters_state_derivative_8cpp_source.html#l00021">tudat::propagators::calculateModifiedRodriguesParametersDerivative()</a>, <a class="el" href="../../d3/d8b/direct_tidal_dissipation_acceleration_partial_8cpp_source.html#l00022">tudat::acceleration_partials::computeDirectTidalAccelerationDueToTideOnPlanetWrtPosition()</a>, <a class="el" href="../../da/d6c/rotational_ephemeris_8cpp_source.html#l00032">tudat::ephemerides::getDerivativeOfRotationMatrixToFrame()</a>, <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00048">quaternionProduct()</a>, <a class="el" href="../../d3/d8c/_simulation_setup_2_environment_setup_2body_8h_source.html#l00567">tudat::simulation_setup::Body::setCurrentRotationalStateToLocalFrame()</a>, and <a class="el" href="../../d5/d27/empirical_acceleration_partial_8cpp_source.html#l00116">tudat::acceleration_partials::EmpiricalAccelerationPartial::update()</a>.</p>

</div>
</div>
<a id="ad8adc85575264c7d94027be05ec3cff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8adc85575264c7d94027be05ec3cff7">&#9670;&nbsp;</a></span>computeCosineOfAngleBetweenVectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::linear_algebra::computeCosineOfAngleBetweenVectors </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Computes the cosine of the angle between two vectors; both vectors must have non-zero norm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector0</td><td>First vector. </td></tr>
    <tr><td class="paramname">vector1</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cosine of angle between vectors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00079">79</a> of file <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html">linearAlgebra.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00108">computeAngleBetweenVectors()</a>, and <a class="el" href="../../d5/d6e/observation_viability_calculator_8cpp_source.html#l00077">tudat::observation_models::BodyAvoidanceAngleCalculator::isObservationViable()</a>.</p>

</div>
</div>
<a id="a705ee32706d9214b89d2d4a155cba1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705ee32706d9214b89d2d4a155cba1d7">&#9670;&nbsp;</a></span>computeAngleBetweenVectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::linear_algebra::computeAngleBetweenVectors </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Computes the angle between two vectors; both vectors must have non-zero norm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector0</td><td>First vector. </td></tr>
    <tr><td class="paramname">vector1</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Angle between vectors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00108">108</a> of file <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html">linearAlgebra.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00079">computeCosineOfAngleBetweenVectors()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d4/dcb/pointing_angles_calculator_8cpp_source.html#l00021">tudat::ground_stations::PointingAnglesCalculator::calculateElevationAngle()</a>, <a class="el" href="../../d4/dcb/pointing_angles_calculator_8cpp_source.html#l00047">tudat::ground_stations::PointingAnglesCalculator::calculatePointingAngles()</a>, <a class="el" href="../../d1/d60/gravity_assist_8cpp_source.html#l00060">tudat::mission_segments::gravityAssist()</a>, and <a class="el" href="../../d6/d95/lambert_routines_8cpp_source.html#l00356">tudat::mission_segments::solveLambertProblemGooding()</a>.</p>

</div>
</div>
<a id="a4b510b13c3fda9293ac7e4739d3fae2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b510b13c3fda9293ac7e4739d3fae2b">&#9670;&nbsp;</a></span>computeNormOfVectorDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::linear_algebra::computeNormOfVectorDifference </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>vector0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Computes the norm of the difference between two 3d vectors (i.e. distance between vectors) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector0</td><td>First vector. </td></tr>
    <tr><td class="paramname">vector1</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Norm of difference between vectors </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00118">118</a> of file <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html">linearAlgebra.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d91/propagation_output_8h_source.html#l00988">tudat::propagators::getDoubleDependentVariableFunction()</a>.</p>

</div>
</div>
<a id="ae83191d4a9df7d3b146350cc9dd0ddb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83191d4a9df7d3b146350cc9dd0ddb3">&#9670;&nbsp;</a></span>getVectorNorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::linear_algebra::getVectorNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Computes the norm of a 3d vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector for which the norm is to be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector norm </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00125">125</a> of file <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html">linearAlgebra.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00138">getVectorNormFromFunction()</a>.</p>

</div>
</div>
<a id="a092a80b83dac4a7a0bd93e9eaf115fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092a80b83dac4a7a0bd93e9eaf115fda">&#9670;&nbsp;</a></span>evaluateSecondBlockInStateVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tudat::linear_algebra::evaluateSecondBlockInStateVector </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a>(const double) &gt;&#160;</td>
          <td class="paramname"><em>stateFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00130">130</a> of file <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html">linearAlgebra.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/deb/create_doppler_partials_8h_source.html#l00146">tudat::observation_partials::createOneWayDopplerPartials()</a>.</p>

</div>
</div>
<a id="ae0150ca2178df1f4c93d658b38c2dcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0150ca2178df1f4c93d658b38c2dcb7">&#9670;&nbsp;</a></span>getVectorNormFromFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::linear_algebra::getVectorNormFromFunction </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; Eigen::Vector3d() &gt;&#160;</td>
          <td class="paramname"><em>vectorFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Computes the norm of a 3d vector from a vector-returning function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectorFunction</td><td>Function returning the vector for which the norm is to be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector norm </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00138">138</a> of file <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html">linearAlgebra.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00125">getVectorNorm()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d91/propagation_output_8h_source.html#l00988">tudat::propagators::getDoubleDependentVariableFunction()</a>.</p>

</div>
</div>
<a id="a4a8b0868a1d5f1c1daf8a243c7f9e840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8b0868a1d5f1c1daf8a243c7f9e840">&#9670;&nbsp;</a></span>calculatePartialOfNormalizedVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix3d tudat::linear_algebra::calculatePartialOfNormalizedVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>partialOfUnnormalizedVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>unnormalizedVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to calculate the jacobian of a normalized vector, from the jacobian of the unnormalized vector.</p>
<p class="">Function to calculate the jacobian (partial matrix) of a normalized vector, from the jacobian (partial matrix) of the unnormalized vector and the unnormalized vector itself, i.e. d/dp(x/|x|) from d/dp(x) and x, with p and x 3d vectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partialOfUnnormalizedVector</td><td>The jacobian of the unnormalized vector </td></tr>
    <tr><td class="paramname">unnormalizedVector</td><td>Unnormalized vector wrt which partialOfUnnormalizedVector is taken </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The jacobian of the normalized vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00144">144</a> of file <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html">linearAlgebra.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/d27/empirical_acceleration_partial_8cpp_source.html#l00116">tudat::acceleration_partials::EmpiricalAccelerationPartial::update()</a>.</p>

</div>
</div>
<a id="aac84507727e00166354321dfb26402be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac84507727e00166354321dfb26402be">&#9670;&nbsp;</a></span>getVectorEntryRootMeanSquare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::linear_algebra::getVectorEntryRootMeanSquare </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>inputVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to compute the root mean square (RMS) value of the entries in an <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputVector</td><td>Vector for which the RMS is to be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RMS of input vector </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html#l00154">154</a> of file <a class="el" href="../../d9/d59/linear_algebra_8cpp_source.html">linearAlgebra.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/de2/orbit_determination_manager_8h_source.html#l00461">tudat::simulation_setup::OrbitDeterminationManager&lt; ObservationScalarType, TimeType, std::enable_if&lt; is_state_scalar_and_time_type&lt; ObservationScalarType, TimeType &gt;::value, int &gt;::type &gt;::estimateParameters()</a>.</p>

</div>
</div>
<a id="aec1b257b4acc43b8efd27ec4adfb81d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1b257b4acc43b8efd27ec4adfb81d2">&#9670;&nbsp;</a></span>computeVectorDifference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int VectorSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; double, VectorSize, 1 &gt; tudat::linear_algebra::computeVectorDifference </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, VectorSize, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, VectorSize, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Computes the difference between two 3d vectors (first input minus second input, i.e vector from second input to first input). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector0</td><td>First vector. </td></tr>
    <tr><td class="paramname">vector1</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Difference between vectors </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d94/linear_algebra_8h_source.html#l00103">103</a> of file <a class="el" href="../../d9/d94/linear_algebra_8h_source.html">linearAlgebra.h</a>.</p>

</div>
</div>
<a id="adf1fb56bc2c52e21c8e78431ea336f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1fb56bc2c52e21c8e78431ea336f21">&#9670;&nbsp;</a></span>flipMatrixRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tudat::linear_algebra::flipMatrixRows </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrixToFlip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Flips all rows of an Eigen-matrix, i.e., order of rows is reversed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrixToFlip</td><td>Matrix that should be flipped. The flipping is done in place, i.e. the input matrix is modified directly (no copies are made). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d94/linear_algebra_8h_source.html#l00142">142</a> of file <a class="el" href="../../d9/d94/linear_algebra_8h_source.html">linearAlgebra.h</a>.</p>

</div>
</div>
<a id="a2e95e3d7af61753bf76023829ce39c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e95e3d7af61753bf76023829ce39c7e">&#9670;&nbsp;</a></span>doesMatrixHaveNanEntries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateScalarType , int NumberOfRows, int NumberOfColumns&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tudat::linear_algebra::doesMatrixHaveNanEntries </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; StateScalarType, NumberOfRows, NumberOfColumns &gt;&#160;</td>
          <td class="paramname"><em>matrixToCheck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Function to check whether an <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> Matrix has any NaN entries </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrixToCheck</td><td><a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> Matrix to check for any NaN entries </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if matrix has NaN entries, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d94/linear_algebra_8h_source.html#l00185">185</a> of file <a class="el" href="../../d9/d94/linear_algebra_8h_source.html">linearAlgebra.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d8/d7e/dynamics_simulator_8h_source.html#l01106">tudat::propagators::MultiArcDynamicsSimulator&lt; StateScalarType, TimeType &gt;::integrateEquationsOfMotion()</a>, and <a class="el" href="../../d5/dd7/variational_equations_solver_8h_source.html#l01107">tudat::propagators::MultiArcVariationalEquationsSolver&lt; StateScalarType, TimeType &gt;::integrateVariationalAndDynamicalEquations()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 14 2018 12:07:26 for Tudat by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
