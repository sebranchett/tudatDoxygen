<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Tudat: tudat::basic_mathematics Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tudat
   </div>
   <div id="projectbrief">TU Delft astrodynamics toolbox</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d6/d6d/namespacetudat.html">tudat</a></li><li class="navelem"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html">basic_mathematics</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tudat::basic_mathematics Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d11/classtudat_1_1basic__mathematics_1_1_basic_function.html">BasicFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d9b/classtudat_1_1basic__mathematics_1_1_function.html" title="Function interface to allow evaluation of a mathematical function. ">Function</a> with basic implementations for derivatives and integrals.  <a href="../../d8/d11/classtudat_1_1basic__mathematics_1_1_basic_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d97/structtudat_1_1basic__mathematics_1_1_convergence_exception.html">ConvergenceException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception indicating that an algorithm could not complete convergence to a solution.  <a href="../../dc/d97/structtudat_1_1basic__mathematics_1_1_convergence_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9b/classtudat_1_1basic__mathematics_1_1_function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d9b/classtudat_1_1basic__mathematics_1_1_function.html" title="Function interface to allow evaluation of a mathematical function. ">Function</a> interface to allow evaluation of a mathematical function.  <a href="../../d0/d9b/classtudat_1_1basic__mathematics_1_1_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d4c/classtudat_1_1basic__mathematics_1_1_function_proxy.html">FunctionProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d9b/classtudat_1_1basic__mathematics_1_1_function.html" title="Function interface to allow evaluation of a mathematical function. ">Function</a> interface to allow evaluation of a mathematical function.  <a href="../../d4/d4c/classtudat_1_1basic__mathematics_1_1_function_proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d1f/classtudat_1_1basic__mathematics_1_1_legendre_cache.html">LegendreCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating and accessing a back-end cache of Legendre polynomials.  <a href="../../dc/d1f/classtudat_1_1basic__mathematics_1_1_legendre_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d69/classtudat_1_1basic__mathematics_1_1_spherical_harmonics_cache.html">SphericalHarmonicsCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache object in which variables that are required for the computation of spherical harmonic potential are stored.  <a href="../../d8/d69/classtudat_1_1basic__mathematics_1_1_spherical_harmonics_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9740ad9bee942a134aac9beb17349fa8"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; <a class="el" href="../../d8/d11/classtudat_1_1basic__mathematics_1_1_basic_function.html">BasicFunction</a>&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a9740ad9bee942a134aac9beb17349fa8">BasicFunctionPointer</a></td></tr>
<tr class="separator:a9740ad9bee942a134aac9beb17349fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6d59540d2cb3f39e65d5fea18e7d9a"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; <a class="el" href="../../d0/d9b/classtudat_1_1basic__mathematics_1_1_function.html">Function</a>&lt;  &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a5d6d59540d2cb3f39e65d5fea18e7d9a">FunctionPointer</a></td></tr>
<tr class="memdesc:a5d6d59540d2cb3f39e65d5fea18e7d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for shared-pointer to <a class="el" href="../../d0/d9b/classtudat_1_1basic__mathematics_1_1_function.html" title="Function interface to allow evaluation of a mathematical function. ">Function</a> object.  <a href="#a5d6d59540d2cb3f39e65d5fea18e7d9a">More...</a><br /></td></tr>
<tr class="separator:a5d6d59540d2cb3f39e65d5fea18e7d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54a4f9d29647e49d4895f78f82e2999"><td class="memItemLeft" align="right" valign="top">typedef boost::mt19937&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#aa54a4f9d29647e49d4895f78f82e2999">GlobalRandomNumberGeneratorType</a></td></tr>
<tr class="memdesc:aa54a4f9d29647e49d4895f78f82e2999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator typedef.  <a href="#aa54a4f9d29647e49d4895f78f82e2999">More...</a><br /></td></tr>
<tr class="separator:aa54a4f9d29647e49d4895f78f82e2999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6be883dcda552bd4ff86bdf3aba2e25"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d4/d4c/classtudat_1_1basic__mathematics_1_1_function_proxy.html">FunctionProxy</a>&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#aa6be883dcda552bd4ff86bdf3aba2e25">UnivariateProxy</a></td></tr>
<tr class="separator:aa6be883dcda552bd4ff86bdf3aba2e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b6fa42aeadab34835c1b139d22d274"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d4/d4c/classtudat_1_1basic__mathematics_1_1_function_proxy.html#ab350957b6bb15fb811624a5ffc0ab60f">UnivariateProxy::FunctionProxyPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ae8b6fa42aeadab34835c1b139d22d274">UnivariateProxyPointer</a></td></tr>
<tr class="separator:ae8b6fa42aeadab34835c1b139d22d274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2020c50d6ba1bb16635a7e8274ca56"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../d4/d4c/classtudat_1_1basic__mathematics_1_1_function_proxy.html#a1861c20597dcc1cbce1e7c455f2d82a9">UnivariateProxy::FunctionSignature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a></td></tr>
<tr class="separator:acf2020c50d6ba1bb16635a7e8274ca56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ada69ad0a09aa8c4f5142fbd0093f0c76"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ada69ad0a09aa8c4f5142fbd0093f0c76">SphericalCoordinatesIndices</a> { <a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ada69ad0a09aa8c4f5142fbd0093f0c76a77dd6ec8036c506dc0cf28b37467b709">radiusIndex</a>, 
<a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ada69ad0a09aa8c4f5142fbd0093f0c76acd7db7cb086ae3b57f0d09df9d0f879a">latitudeIndex</a>, 
<a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ada69ad0a09aa8c4f5142fbd0093f0c76a4f200336fe63cb321957b75b5d89faee">longitudeIndex</a>
 }<tr class="memdesc:ada69ad0a09aa8c4f5142fbd0093f0c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spherical coordinate indices.  <a href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ada69ad0a09aa8c4f5142fbd0093f0c76">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ada69ad0a09aa8c4f5142fbd0093f0c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a36972723d016b7db39d92ccdc018cc0b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a36972723d016b7db39d92ccdc018cc0b">calculateLegendreGeodesyNormalizationFactor</a> (const int degree, const int order)</td></tr>
<tr class="memdesc:a36972723d016b7db39d92ccdc018cc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d9b/classtudat_1_1basic__mathematics_1_1_function.html" title="Function interface to allow evaluation of a mathematical function. ">Function</a> to calculate the normalization factor for Legendre polynomials to geodesy-normalized.  <a href="#a36972723d016b7db39d92ccdc018cc0b">More...</a><br /></td></tr>
<tr class="separator:a36972723d016b7db39d92ccdc018cc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad517ca542d264b6a7d33abbf027798e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#aad517ca542d264b6a7d33abbf027798e">computeGeodesyLegendrePolynomial</a> (const int degree, const int order, const double legendreParameter)</td></tr>
<tr class="memdesc:aad517ca542d264b6a7d33abbf027798e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute geodesy-normalized associated Legendre polynomial.  <a href="#aad517ca542d264b6a7d33abbf027798e">More...</a><br /></td></tr>
<tr class="separator:aad517ca542d264b6a7d33abbf027798e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab192c93cfab1232132719a683d6ae688"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ab192c93cfab1232132719a683d6ae688">computeGeodesyLegendrePolynomialDerivative</a> (const int degree, const int order, const double polynomialParameter, const double currentLegendrePolynomial, const double incrementedLegendrePolynomial, const double normalizationCorrection)</td></tr>
<tr class="memdesc:ab192c93cfab1232132719a683d6ae688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute derivative of geodesy-normalized Legendre polynomial.  <a href="#ab192c93cfab1232132719a683d6ae688">More...</a><br /></td></tr>
<tr class="separator:ab192c93cfab1232132719a683d6ae688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85094d571a57ad3ad94173224aa33b55"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a85094d571a57ad3ad94173224aa33b55">computeGeodesyLegendrePolynomialDerivative</a> (const int degree, const int order, const double polynomialParameter, const double currentLegendrePolynomial, const double incrementedLegendrePolynomial)</td></tr>
<tr class="memdesc:a85094d571a57ad3ad94173224aa33b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute derivative of geodesy-normalized Legendre polynomial.  <a href="#a85094d571a57ad3ad94173224aa33b55">More...</a><br /></td></tr>
<tr class="separator:a85094d571a57ad3ad94173224aa33b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8db058213b11d973862d8d6c2841a3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a9c8db058213b11d973862d8d6c2841a3">computeGeodesyLegendrePolynomialDiagonal</a> (const int degree, const double degreeOneOrderOnePolynomial, const double priorSectoralPolynomial)</td></tr>
<tr class="memdesc:a9c8db058213b11d973862d8d6c2841a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute geodesy-normalized Legendre polynomial through sectoral recursion.  <a href="#a9c8db058213b11d973862d8d6c2841a3">More...</a><br /></td></tr>
<tr class="separator:a9c8db058213b11d973862d8d6c2841a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f3dbf703116044abad0da08ca7a870"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ae2f3dbf703116044abad0da08ca7a870">computeGeodesyLegendrePolynomialExplicit</a> (const int degree, const int order, const double polynomialParameter)</td></tr>
<tr class="memdesc:ae2f3dbf703116044abad0da08ca7a870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute low degree/order geodesy-normalized Legendre polynomials explicitly.  <a href="#ae2f3dbf703116044abad0da08ca7a870">More...</a><br /></td></tr>
<tr class="separator:ae2f3dbf703116044abad0da08ca7a870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c6b72f4a30ea76e48b11f72e3f7f6a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a16c6b72f4a30ea76e48b11f72e3f7f6a">computeGeodesyLegendrePolynomialFromCache</a> (const int degree, const int order, <a class="el" href="../../dc/d1f/classtudat_1_1basic__mathematics_1_1_legendre_cache.html">LegendreCache</a> &amp;geodesyLegendreCache)</td></tr>
<tr class="memdesc:a16c6b72f4a30ea76e48b11f72e3f7f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute geodesy-normalized associated Legendre polynomial.  <a href="#a16c6b72f4a30ea76e48b11f72e3f7f6a">More...</a><br /></td></tr>
<tr class="separator:a16c6b72f4a30ea76e48b11f72e3f7f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdf97455465f9cbf9fdc348c7969f49"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a0bdf97455465f9cbf9fdc348c7969f49">computeGeodesyLegendrePolynomialSecondDerivative</a> (const int degree, const int order, const double polynomialParameter, const double currentLegendrePolynomial, const double incrementedLegendrePolynomial, const double currentLegendrePolynomialDerivative, const double incrementedLegendrePolynomialDerivative, const double normalizationCorrection)</td></tr>
<tr class="memdesc:a0bdf97455465f9cbf9fdc348c7969f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute second derivative of geodesy-normalized associated Legendre polynomial.  <a href="#a0bdf97455465f9cbf9fdc348c7969f49">More...</a><br /></td></tr>
<tr class="separator:a0bdf97455465f9cbf9fdc348c7969f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3ab08d7ccfd21e8ca3cc0b92587b59"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a9d3ab08d7ccfd21e8ca3cc0b92587b59">computeGeodesyLegendrePolynomialVertical</a> (const int degree, const int order, const double polynomialParameter, const double oneDegreePriorPolynomial, const double twoDegreesPriorPolynomial)</td></tr>
<tr class="memdesc:a9d3ab08d7ccfd21e8ca3cc0b92587b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute geodesy-normalized Legendre polynomial through degree recursion.  <a href="#a9d3ab08d7ccfd21e8ca3cc0b92587b59">More...</a><br /></td></tr>
<tr class="separator:a9d3ab08d7ccfd21e8ca3cc0b92587b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410e8dd4001c35b34fb1505f78b6fda6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a410e8dd4001c35b34fb1505f78b6fda6">computeLegendrePolynomial</a> (const int degree, const int order, const double legendreParameter)</td></tr>
<tr class="memdesc:a410e8dd4001c35b34fb1505f78b6fda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute unnormalized associated Legendre polynomial.  <a href="#a410e8dd4001c35b34fb1505f78b6fda6">More...</a><br /></td></tr>
<tr class="separator:a410e8dd4001c35b34fb1505f78b6fda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f9ea0c3e6f1c496774db4168111613"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a28f9ea0c3e6f1c496774db4168111613">computeLegendrePolynomialDerivative</a> (const int order, const double polynomialParameter, const double currentLegendrePolynomial, const double incrementedLegendrePolynomial)</td></tr>
<tr class="memdesc:a28f9ea0c3e6f1c496774db4168111613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute derivative of unnormalized Legendre polynomial.  <a href="#a28f9ea0c3e6f1c496774db4168111613">More...</a><br /></td></tr>
<tr class="separator:a28f9ea0c3e6f1c496774db4168111613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043b86135da3bd5ce68bbd5d3500f4d4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a043b86135da3bd5ce68bbd5d3500f4d4">computeLegendrePolynomialDiagonal</a> (const int degree, const double degreeOneOrderOnePolynomial, const double priorSectoralPolynomial)</td></tr>
<tr class="memdesc:a043b86135da3bd5ce68bbd5d3500f4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute unnormalized Legendre polynomial through sectoral recursion.  <a href="#a043b86135da3bd5ce68bbd5d3500f4d4">More...</a><br /></td></tr>
<tr class="separator:a043b86135da3bd5ce68bbd5d3500f4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42836ef41e0dd05b2a7f6d9796223a1f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a42836ef41e0dd05b2a7f6d9796223a1f">computeLegendrePolynomialExplicit</a> (const int degree, const int order, const double polynomialParameter)</td></tr>
<tr class="memdesc:a42836ef41e0dd05b2a7f6d9796223a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute low degree/order unnormalized Legendre polynomial explicitly.  <a href="#a42836ef41e0dd05b2a7f6d9796223a1f">More...</a><br /></td></tr>
<tr class="separator:a42836ef41e0dd05b2a7f6d9796223a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425517e4019a24999ca565085604a6c2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a425517e4019a24999ca565085604a6c2">computeLegendrePolynomialFromCache</a> (const int degree, const int order, <a class="el" href="../../dc/d1f/classtudat_1_1basic__mathematics_1_1_legendre_cache.html">LegendreCache</a> &amp;legendreCache)</td></tr>
<tr class="memdesc:a425517e4019a24999ca565085604a6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute unnormalized associated Legendre polynomial.  <a href="#a425517e4019a24999ca565085604a6c2">More...</a><br /></td></tr>
<tr class="separator:a425517e4019a24999ca565085604a6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fce33bb9876f706aae0674b399d41ff"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a6fce33bb9876f706aae0674b399d41ff">computeLegendrePolynomialVertical</a> (const int degree, const int order, const double polynomialParameter, const double oneDegreePriorPolynomial, const double twoDegreesPriorPolynomial)</td></tr>
<tr class="memdesc:a6fce33bb9876f706aae0674b399d41ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute unnormalized Legendre polynomial through degree recursion.  <a href="#a6fce33bb9876f706aae0674b399d41ff">More...</a><br /></td></tr>
<tr class="separator:a6fce33bb9876f706aae0674b399d41ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c396ee27cf7e4f0562296ebba9526f8"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType  = double&gt; </td></tr>
<tr class="memitem:a3c396ee27cf7e4f0562296ebba9526f8"><td class="memTemplItemLeft" align="right" valign="top">ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a3c396ee27cf7e4f0562296ebba9526f8">computeModulo</a> (const ScalarType dividend, const ScalarType divisor)</td></tr>
<tr class="memdesc:a3c396ee27cf7e4f0562296ebba9526f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute modulo of floating-point number (default double).  <a href="#a3c396ee27cf7e4f0562296ebba9526f8">More...</a><br /></td></tr>
<tr class="separator:a3c396ee27cf7e4f0562296ebba9526f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7c9774b7cf65db6bd67a8a4dcc18a9"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a1f7c9774b7cf65db6bd67a8a4dcc18a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a1f7c9774b7cf65db6bd67a8a4dcc18a9">computeModuloAndRemainder</a> (const ScalarType dividend, const ScalarType divisor, ScalarType &amp;moduloValue, int &amp;numberOfDivisors)</td></tr>
<tr class="memdesc:a1f7c9774b7cf65db6bd67a8a4dcc18a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute modulo of floating-point number (default double).  <a href="#a1f7c9774b7cf65db6bd67a8a4dcc18a9">More...</a><br /></td></tr>
<tr class="separator:a1f7c9774b7cf65db6bd67a8a4dcc18a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0338c727149f283911719894d6ed44c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a0338c727149f283911719894d6ed44c8">computeNearestLeftNeighborUsingBinarySearch</a> (const Eigen::VectorXd &amp;vectorOfSortedData, const double targetValueInVectorOfSortedData)</td></tr>
<tr class="memdesc:a0338c727149f283911719894d6ed44c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest left neighbor binary search.  <a href="#a0338c727149f283911719894d6ed44c8">More...</a><br /></td></tr>
<tr class="separator:a0338c727149f283911719894d6ed44c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3629b671b410d55e7d4346d2b40ed122"><td class="memTemplParams" colspan="2">template&lt;typename IndependentVariableType &gt; </td></tr>
<tr class="memitem:a3629b671b410d55e7d4346d2b40ed122"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a3629b671b410d55e7d4346d2b40ed122">computeNearestLeftNeighborUsingBinarySearch</a> (const std::vector&lt; IndependentVariableType &gt; vectorOfSortedData, const IndependentVariableType targetValueInVectorOfSortedData)</td></tr>
<tr class="memdesc:a3629b671b410d55e7d4346d2b40ed122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated nearest left neighbor binary search.  <a href="#a3629b671b410d55e7d4346d2b40ed122">More...</a><br /></td></tr>
<tr class="separator:a3629b671b410d55e7d4346d2b40ed122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967e6cb5f0b7b4e05bdf1bd9e8577f05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a967e6cb5f0b7b4e05bdf1bd9e8577f05">computeNearestLeftNeighborUsingBinarySearch</a> (const std::map&lt; double, Eigen::VectorXd &gt; &amp;sortedIndepedentAndDependentVariables, const double targetValueInMapOfData)</td></tr>
<tr class="memdesc:a967e6cb5f0b7b4e05bdf1bd9e8577f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest left neighbor binary search.  <a href="#a967e6cb5f0b7b4e05bdf1bd9e8577f05">More...</a><br /></td></tr>
<tr class="separator:a967e6cb5f0b7b4e05bdf1bd9e8577f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623b22dbb2ba19fb45991c82fd76c9e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a623b22dbb2ba19fb45991c82fd76c9e7">computeNearestNeighborUsingBinarySearch</a> (const Eigen::VectorXd &amp;vectorOfSortedData, const double targetValueInVectorOfSortedData)</td></tr>
<tr class="memdesc:a623b22dbb2ba19fb45991c82fd76c9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest neighbor binary search.  <a href="#a623b22dbb2ba19fb45991c82fd76c9e7">More...</a><br /></td></tr>
<tr class="separator:a623b22dbb2ba19fb45991c82fd76c9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7d242d59760af59b348d3ce4064b18"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#afe7d242d59760af59b348d3ce4064b18">computePotentialGradient</a> (const double distance, const double radiusPowerTerm, const double cosineOfOrderLongitude, const double sineOfOrderLongitude, const double cosineOfLatitude, const double preMultiplier, const int degree, const int order, const double cosineHarmonicCoefficient, const double sineHarmonicCoefficient, const double legendrePolynomial, const double legendrePolynomialDerivative)</td></tr>
<tr class="memdesc:afe7d242d59760af59b348d3ce4064b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of a single term of a spherical harmonics potential field.  <a href="#afe7d242d59760af59b348d3ce4064b18">More...</a><br /></td></tr>
<tr class="separator:afe7d242d59760af59b348d3ce4064b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93695b85b89b0120ca8b2d63e758e9e"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ae93695b85b89b0120ca8b2d63e758e9e">computePotentialGradient</a> (const Eigen::Vector3d &amp;sphericalPosition, const double referenceRadius, const double preMultiplier, const int degree, const int order, const double cosineHarmonicCoefficient, const double sineHarmonicCoefficient, const double legendrePolynomial, const double legendrePolynomialDerivative)</td></tr>
<tr class="memdesc:ae93695b85b89b0120ca8b2d63e758e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of a single term of a spherical harmonics potential field.  <a href="#ae93695b85b89b0120ca8b2d63e758e9e">More...</a><br /></td></tr>
<tr class="separator:ae93695b85b89b0120ca8b2d63e758e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64d30d8ff066d9c4ecee48c8b896d69"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ac64d30d8ff066d9c4ecee48c8b896d69">computePotentialGradient</a> (const Eigen::Vector3d &amp;sphericalPosition, const double preMultiplier, const int degree, const int order, const double cosineHarmonicCoefficient, const double sineHarmonicCoefficient, const double legendrePolynomial, const double legendrePolynomialDerivative, const boost::shared_ptr&lt; <a class="el" href="../../d8/d69/classtudat_1_1basic__mathematics_1_1_spherical_harmonics_cache.html">SphericalHarmonicsCache</a> &gt; sphericalHarmonicsCache)</td></tr>
<tr class="memdesc:ac64d30d8ff066d9c4ecee48c8b896d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of a single term of a spherical harmonics potential field.  <a href="#ac64d30d8ff066d9c4ecee48c8b896d69">More...</a><br /></td></tr>
<tr class="separator:ac64d30d8ff066d9c4ecee48c8b896d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e01a3523a4a296e577f3e95ae1c2014"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a4e01a3523a4a296e577f3e95ae1c2014">computeRotationOfPointAboutArbitraryAxis</a> (const Eigen::Vector3d &amp;originOfRotation, const double angleOfRotation, const Eigen::Vector3d &amp;axisOfRotation, const Eigen::Vector3d &amp;initialPositionOfPoint)</td></tr>
<tr class="memdesc:a4e01a3523a4a296e577f3e95ae1c2014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rotation of point about arbitrary axis.  <a href="#a4e01a3523a4a296e577f3e95ae1c2014">More...</a><br /></td></tr>
<tr class="separator:a4e01a3523a4a296e577f3e95ae1c2014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c62bb9afe019a4a061b8c40ad1f55d"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a54c62bb9afe019a4a061b8c40ad1f55d">computeRotationOfVectorAboutArbitraryAxis</a> (const Eigen::Vector3d &amp;originOfRotation, const double angleOfRotation, const Eigen::Vector3d &amp;axisOfRotation, const Eigen::Vector3d &amp;initialPositionOfVectorTail, const Eigen::Vector3d &amp;initialVector)</td></tr>
<tr class="memdesc:a54c62bb9afe019a4a061b8c40ad1f55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rotation of vector about arbitrary axis.  <a href="#a54c62bb9afe019a4a061b8c40ad1f55d">More...</a><br /></td></tr>
<tr class="separator:a54c62bb9afe019a4a061b8c40ad1f55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a2a1955501e2a3aa7a25768ae5e599"><td class="memTemplParams" colspan="2">template&lt;typename IndependentVariableType &gt; </td></tr>
<tr class="memitem:a20a2a1955501e2a3aa7a25768ae5e599"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a20a2a1955501e2a3aa7a25768ae5e599">findNearestLeftNeighbourUsingHuntingAlgorithm</a> (const IndependentVariableType independentVariableValue, const int previousNearestLowerIndex_, const std::vector&lt; IndependentVariableType &gt; &amp;independentValues_)</td></tr>
<tr class="memdesc:a20a2a1955501e2a3aa7a25768ae5e599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest left leighbour search using hunting algorithm.  <a href="#a20a2a1955501e2a3aa7a25768ae5e599">More...</a><br /></td></tr>
<tr class="separator:a20a2a1955501e2a3aa7a25768ae5e599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8648bd5055681518d25e25d50db424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#aa54a4f9d29647e49d4895f78f82e2999">GlobalRandomNumberGeneratorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a5d8648bd5055681518d25e25d50db424">getGlobalRandomNumberGenerator</a> ()</td></tr>
<tr class="memdesc:a5d8648bd5055681518d25e25d50db424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get global random number generator.  <a href="#a5d8648bd5055681518d25e25d50db424">More...</a><br /></td></tr>
<tr class="separator:a5d8648bd5055681518d25e25d50db424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab485a5660b41a17e0fe33e945d16bda7"><td class="memTemplParams" colspan="2">template&lt;typename IndependentVariableType &gt; </td></tr>
<tr class="memitem:ab485a5660b41a17e0fe33e945d16bda7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ab485a5660b41a17e0fe33e945d16bda7">isIndependentVariableInInterval</a> (const int lowerIndex, const IndependentVariableType independentVariableValue, const std::vector&lt; IndependentVariableType &gt; &amp;independentValues)</td></tr>
<tr class="memdesc:ab485a5660b41a17e0fe33e945d16bda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether a value is in a given interval of a sorted vector.  <a href="#ab485a5660b41a17e0fe33e945d16bda7">More...</a><br /></td></tr>
<tr class="separator:ab485a5660b41a17e0fe33e945d16bda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebdb5a53e6f007bcab0900631a06f5a"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:adebdb5a53e6f007bcab0900631a06f5a"><td class="memTemplItemLeft" align="right" valign="top">ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#adebdb5a53e6f007bcab0900631a06f5a">raiseToIntegerPower</a> (const ScalarType baseValue, const int integerPower)</td></tr>
<tr class="memdesc:adebdb5a53e6f007bcab0900631a06f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise floating point variable to integer power.  <a href="#adebdb5a53e6f007bcab0900631a06f5a">More...</a><br /></td></tr>
<tr class="separator:adebdb5a53e6f007bcab0900631a06f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada554bde7147752798a94b8744c746ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ae8b6fa42aeadab34835c1b139d22d274">UnivariateProxyPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ada554bde7147752798a94b8744c746ba">univariateProxy</a> (<a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a> function)</td></tr>
<tr class="memdesc:ada554bde7147752798a94b8744c746ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for creating a UnivariateProxyPointer from a C++ function UnivariateSignature.  <a href="#ada554bde7147752798a94b8744c746ba">More...</a><br /></td></tr>
<tr class="separator:ada554bde7147752798a94b8744c746ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e8eebb5776ebb6ed7071eff91548d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ae8b6fa42aeadab34835c1b139d22d274">UnivariateProxyPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ae1e8eebb5776ebb6ed7071eff91548d0">univariateProxy</a> (<a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a> function, const int order1, <a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a> function1)</td></tr>
<tr class="separator:ae1e8eebb5776ebb6ed7071eff91548d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec64b8b93bc615097ef3eacdf0c9988"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ae8b6fa42aeadab34835c1b139d22d274">UnivariateProxyPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#adec64b8b93bc615097ef3eacdf0c9988">univariateProxy</a> (<a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a> function, const int order1, <a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a> function1, const int order2, <a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a> function2)</td></tr>
<tr class="separator:adec64b8b93bc615097ef3eacdf0c9988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d43423e3ff4de866364b173f0a7b000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ae8b6fa42aeadab34835c1b139d22d274">UnivariateProxyPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a5d43423e3ff4de866364b173f0a7b000">univariateProxy</a> (<a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a> function, const int order1, <a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a> function1, const int order2, <a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a> function2, const int order3, <a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a> function3)</td></tr>
<tr class="separator:a5d43423e3ff4de866364b173f0a7b000"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a514fd17ae4b3bc45191ece95ca3d8b15"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="../../dc/d1f/classtudat_1_1basic__mathematics_1_1_legendre_cache.html#aa09fa0b6f9b5fc3ce708d5f365d0f6f4">LegendreCache::LegendrePolynomialFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a514fd17ae4b3bc45191ece95ca3d8b15">geodesyNormalizedLegendrePolynomialFunction</a></td></tr>
<tr class="memdesc:a514fd17ae4b3bc45191ece95ca3d8b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefine boost function for geodesy-normalized Legendre polynomial.  <a href="#a514fd17ae4b3bc45191ece95ca3d8b15">More...</a><br /></td></tr>
<tr class="separator:a514fd17ae4b3bc45191ece95ca3d8b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbcf01f29c18b310ddeadaaef054859"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../dc/d1f/classtudat_1_1basic__mathematics_1_1_legendre_cache.html#aa09fa0b6f9b5fc3ce708d5f365d0f6f4">LegendreCache::LegendrePolynomialFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a8bbcf01f29c18b310ddeadaaef054859">regularLegendrePolynomialFunction</a></td></tr>
<tr class="memdesc:a8bbcf01f29c18b310ddeadaaef054859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefine boost function for unnormalized Legendre polynomial.  <a href="#a8bbcf01f29c18b310ddeadaaef054859">More...</a><br /></td></tr>
<tr class="separator:a8bbcf01f29c18b310ddeadaaef054859"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a9740ad9bee942a134aac9beb17349fa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt; <a class="el" href="../../d8/d11/classtudat_1_1basic__mathematics_1_1_basic_function.html">BasicFunction</a>&lt; double, double &gt; &gt; <a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a9740ad9bee942a134aac9beb17349fa8">tudat::basic_mathematics::BasicFunctionPointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../de/d72/basic_function_8h_source.html#l00138">138</a> of file <a class="el" href="../../de/d72/basic_function_8h_source.html">basicFunction.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa54a4f9d29647e49d4895f78f82e2999"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::mt19937 <a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#aa54a4f9d29647e49d4895f78f82e2999">tudat::basic_mathematics::GlobalRandomNumberGeneratorType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Random number generator typedef. This can be modified to any other Boost random number generator type (<a href="http://www.boost.org/doc/libs/1_47_0/doc/html/boost_random/reference.html">http://www.boost.org/doc/libs/1_47_0/doc/html/boost_random/reference.html</a>). </p>

<p>Definition at line <a class="el" href="../../df/d63/basic_mathematics_functions_8h_source.html#l00037">37</a> of file <a class="el" href="../../df/d63/basic_mathematics_functions_8h_source.html">basicMathematicsFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5d6d59540d2cb3f39e65d5fea18e7d9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt; <a class="el" href="../../d0/d9b/classtudat_1_1basic__mathematics_1_1_function.html">Function</a>&lt; &gt; &gt; <a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a5d6d59540d2cb3f39e65d5fea18e7d9a">tudat::basic_mathematics::FunctionPointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for shared-pointer to <a class="el" href="../../d0/d9b/classtudat_1_1basic__mathematics_1_1_function.html" title="Function interface to allow evaluation of a mathematical function. ">Function</a> object with IndependentVariable=double, DependentVariable=double. </p>

<p>Definition at line <a class="el" href="../../dd/d67/function_8h_source.html#l00079">79</a> of file <a class="el" href="../../dd/d67/function_8h_source.html">function.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa6be883dcda552bd4ff86bdf3aba2e25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d4/d4c/classtudat_1_1basic__mathematics_1_1_function_proxy.html">FunctionProxy</a>&lt; double, double &gt; <a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#aa6be883dcda552bd4ff86bdf3aba2e25">tudat::basic_mathematics::UnivariateProxy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/db0/function_proxy_8h_source.html#l00138">138</a> of file <a class="el" href="../../d0/db0/function_proxy_8h_source.html">functionProxy.h</a>.</p>

</div>
</div>
<a class="anchor" id="acf2020c50d6ba1bb16635a7e8274ca56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d4/d4c/classtudat_1_1basic__mathematics_1_1_function_proxy.html#a1861c20597dcc1cbce1e7c455f2d82a9">UnivariateProxy::FunctionSignature</a> <a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">tudat::basic_mathematics::UnivariateSignature</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/db0/function_proxy_8h_source.html#l00139">139</a> of file <a class="el" href="../../d0/db0/function_proxy_8h_source.html">functionProxy.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae8b6fa42aeadab34835c1b139d22d274"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../d4/d4c/classtudat_1_1basic__mathematics_1_1_function_proxy.html#ab350957b6bb15fb811624a5ffc0ab60f">UnivariateProxy::FunctionProxyPointer</a> <a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ae8b6fa42aeadab34835c1b139d22d274">tudat::basic_mathematics::UnivariateProxyPointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../d0/db0/function_proxy_8h_source.html#l00140">140</a> of file <a class="el" href="../../d0/db0/function_proxy_8h_source.html">functionProxy.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ada69ad0a09aa8c4f5142fbd0093f0c76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ada69ad0a09aa8c4f5142fbd0093f0c76">tudat::basic_mathematics::SphericalCoordinatesIndices</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ada69ad0a09aa8c4f5142fbd0093f0c76a77dd6ec8036c506dc0cf28b37467b709"></a>radiusIndex&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ada69ad0a09aa8c4f5142fbd0093f0c76acd7db7cb086ae3b57f0d09df9d0f879a"></a>latitudeIndex&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ada69ad0a09aa8c4f5142fbd0093f0c76a4f200336fe63cb321957b75b5d89faee"></a>longitudeIndex&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="../../d3/d4c/spherical_harmonics_8h_source.html#l00250">250</a> of file <a class="el" href="../../d3/d4c/spherical_harmonics_8h_source.html">sphericalHarmonics.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5d8648bd5055681518d25e25d50db424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#aa54a4f9d29647e49d4895f78f82e2999">GlobalRandomNumberGeneratorType</a> &amp; tudat::basic_mathematics::getGlobalRandomNumberGenerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns global random number generator. The default seed is set to the current time. </p><dl class="section return"><dt>Returns</dt><dd>Global random number generator. </dd></dl>

<p>Definition at line <a class="el" href="../../df/dd3/basic_mathematics_functions_8cpp_source.html#l00023">23</a> of file <a class="el" href="../../df/dd3/basic_mathematics_functions_8cpp_source.html">basicMathematicsFunctions.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c396ee27cf7e4f0562296ebba9526f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ScalarType tudat::basic_mathematics::computeModulo </td>
          <td>(</td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the remainder of division of one floating-point number by another. The modulo computation is based on the mathematical definition of congruence, which is different from the implementation of std::fmod() in the cmath standard library. For a description of congruence see: <a href="http://mathworld.wolfram.com/Congruence.html">http://mathworld.wolfram.com/Congruence.html</a>. The remainder is in the range [ 0, divisor ). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dividend</td><td>Number to be divided. </td></tr>
    <tr><td class="paramname">divisor</td><td>Number that is divided by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Remainder of division of dividend by divisor. </dd></dl>

<p>Definition at line <a class="el" href="../../df/d63/basic_mathematics_functions_8h_source.html#l00058">58</a> of file <a class="el" href="../../df/d63/basic_mathematics_functions_8h_source.html">basicMathematicsFunctions.h</a>.</p>

<p>Referenced by <a class="el" href="../../d2/d70/reference_frame_transformations_8cpp_source.html#l00044">tudat::reference_frames::calculateInertialToPlanetFixedRotationAnglesFromMatrix()</a>, <a class="el" href="../../d0/d84/basic_statistics_8cpp_source.html#l00086">tudat::statistics::computeSampleMedian()</a>, <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00145">tudat::coordinate_conversions::convertCartesianToCylindrical()</a>, <a class="el" href="../../dd/de6/modified_equinoctial_element_conversions_8cpp_source.html#l00053">tudat::orbital_element_conversions::convertKeplerianToModifiedEquinoctialElements()</a>, <a class="el" href="../../dd/de6/modified_equinoctial_element_conversions_8cpp_source.html#l00151">tudat::orbital_element_conversions::convertModifiedEquinoctialToKeplerianElements()</a>, <a class="el" href="../../d7/d48/simple_rotational_ephemeris_8cpp_source.html#l00037">tudat::ephemerides::SimpleRotationalEphemeris::getDerivativeOfRotationToTargetFrame()</a>, <a class="el" href="../../d0/d61/approximate_planet_positions_8cpp_source.html#l00042">tudat::ephemerides::ApproximatePlanetPositions::getKeplerianStateFromEphemeris()</a>, and <a class="el" href="../../d7/d48/simple_rotational_ephemeris_8cpp_source.html#l00023">tudat::ephemerides::SimpleRotationalEphemeris::getRotationToTargetFrame()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f7c9774b7cf65db6bd67a8a4dcc18a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tudat::basic_mathematics::computeModuloAndRemainder </td>
          <td>(</td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>divisor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType &amp;&#160;</td>
          <td class="paramname"><em>moduloValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberOfDivisors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the remainder of division of one floating-point number by another. The modulo computation is based on the mathematical definition of congruence, which is different from the implementation of std::fmod() in the cmath standard library. For a description of congruence see: <a href="http://mathworld.wolfram.com/Congruence.html">http://mathworld.wolfram.com/Congruence.html</a>. The remainder is in the range [ 0, divisor ). This function also returns (by reference) the number of times divisor goes into dividend, i.e. the division from which the moduloValue is the remainder. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dividend</td><td>Number to be divided. </td></tr>
    <tr><td class="paramname">divisor</td><td>Number that is divided by. </td></tr>
    <tr><td class="paramname">moduloValue</td><td>Remainder of division of dividend by divisor (returned by reference). </td></tr>
    <tr><td class="paramname">numberOfDivisors</td><td>Number of times divisor goes into dividend (returned by reference). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../df/d63/basic_mathematics_functions_8h_source.html#l00077">77</a> of file <a class="el" href="../../df/d63/basic_mathematics_functions_8h_source.html">basicMathematicsFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="adebdb5a53e6f007bcab0900631a06f5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ScalarType tudat::basic_mathematics::raiseToIntegerPower </td>
          <td>(</td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>baseValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>integerPower</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="../../df/d63/basic_mathematics_functions_8h_source.html#l00087">87</a> of file <a class="el" href="../../df/d63/basic_mathematics_functions_8h_source.html">basicMathematicsFunctions.h</a>.</p>

<p>Referenced by <a class="el" href="../../d9/d20/tidal_love_number_partial_interface_8cpp_source.html#l00321">tudat::orbit_determination::TidalLoveNumberPartialInterface::calculateCoefficientPartialWrtRealTidalLoveNumber()</a>, <a class="el" href="../../da/d06/spherical_harmonics_8cpp_source.html#l00075">computePotentialGradient()</a>, and <a class="el" href="../../d6/d71/spherical_harmonic_partial_functions_8cpp_source.html#l00075">tudat::acceleration_partials::computePotentialSphericalHessian()</a>.</p>

</div>
</div>
<a class="anchor" id="ada554bde7147752798a94b8744c746ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ae8b6fa42aeadab34835c1b139d22d274">UnivariateProxyPointer</a> tudat::basic_mathematics::univariateProxy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a>&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>C++ function representing the mathematical function. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d0/db0/function_proxy_8h_source.html#l00146">146</a> of file <a class="el" href="../../d0/db0/function_proxy_8h_source.html">functionProxy.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae1e8eebb5776ebb6ed7071eff91548d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ae8b6fa42aeadab34835c1b139d22d274">UnivariateProxyPointer</a> tudat::basic_mathematics::univariateProxy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a>&#160;</td>
          <td class="paramname"><em>function1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory for creating a UnivaritateProxyPtr from a C++ function UnivariateSignature, with one additional binding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>C++ function representing the mathematical function. </td></tr>
    <tr><td class="paramname">order1</td><td>Order of the additional derivative or integral function, i.e. order of function1. </td></tr>
    <tr><td class="paramname">function1</td><td>Additional derivative or integral representation to bind. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d0/db0/function_proxy_8h_source.html#l00160">160</a> of file <a class="el" href="../../d0/db0/function_proxy_8h_source.html">functionProxy.h</a>.</p>

</div>
</div>
<a class="anchor" id="adec64b8b93bc615097ef3eacdf0c9988"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ae8b6fa42aeadab34835c1b139d22d274">UnivariateProxyPointer</a> tudat::basic_mathematics::univariateProxy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a>&#160;</td>
          <td class="paramname"><em>function1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a>&#160;</td>
          <td class="paramname"><em>function2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory for creating a UnivariateProxyPointer from a C++ function UnivariateSignature, with two additional binding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>C++ function representing the mathematical function. </td></tr>
    <tr><td class="paramname">order1</td><td>Order of the first additional derivative or integral function, i.e. order of function1. </td></tr>
    <tr><td class="paramname">function1</td><td>First additional derivative or integral representation to bind. </td></tr>
    <tr><td class="paramname">order2</td><td>Order of the second additional derivative or integral function, i.e. order of function2. </td></tr>
    <tr><td class="paramname">function2</td><td>Second additional derivative or integral representation to bind. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d0/db0/function_proxy_8h_source.html#l00184">184</a> of file <a class="el" href="../../d0/db0/function_proxy_8h_source.html">functionProxy.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5d43423e3ff4de866364b173f0a7b000"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#ae8b6fa42aeadab34835c1b139d22d274">UnivariateProxyPointer</a> tudat::basic_mathematics::univariateProxy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a>&#160;</td>
          <td class="paramname"><em>function1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a>&#160;</td>
          <td class="paramname"><em>function2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#acf2020c50d6ba1bb16635a7e8274ca56">UnivariateSignature</a>&#160;</td>
          <td class="paramname"><em>function3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory for creating a UnivariateProxyPointer from a C++ function UnivariateSignature, with three additional binding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>C++ function representing the mathematical function. </td></tr>
    <tr><td class="paramname">order1</td><td>Order of the first additional derivative or integral function, i.e. order of function1. </td></tr>
    <tr><td class="paramname">function1</td><td>First additional derivative or integral representation to bind. </td></tr>
    <tr><td class="paramname">order2</td><td>Order of the second additional derivative or integral function, i.e. order of function2. </td></tr>
    <tr><td class="paramname">function2</td><td>Second additional derivative or integral representation to bind. </td></tr>
    <tr><td class="paramname">order3</td><td>Order of the third additional derivative or integral function, i.e. order of function3. </td></tr>
    <tr><td class="paramname">function3</td><td>Third additional derivative or integral representation to bind. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d0/db0/function_proxy_8h_source.html#l00213">213</a> of file <a class="el" href="../../d0/db0/function_proxy_8h_source.html">functionProxy.h</a>.</p>

</div>
</div>
<a class="anchor" id="a425517e4019a24999ca565085604a6c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::computeLegendrePolynomialFromCache </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d1f/classtudat_1_1basic__mathematics_1_1_legendre_cache.html">LegendreCache</a> &amp;&#160;</td>
          <td class="paramname"><em>legendreCache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns an unnormalized associated Legendre polynomial <img class="formulaInl" alt="$ P _{ n, m }( u ) $" src="../../form_125.png"/> with degree <img class="formulaInl" alt="$ n $" src="../../form_12.png"/>, order <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> and polynomial parameter <img class="formulaInl" alt="$ u $" src="../../form_126.png"/>. <img class="formulaInl" alt="$ P _{ n, m }( u ) $" src="../../form_125.png"/> obeys the definition given by Vallado [2001]: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P _{ n, m } ( u ) = ( 1 - u ^ 2 ) ^ { m / 2 } \frac{ d ^ m }{ du ^ m } \left[ P_n ( u ) \right] \textrm{ for }n \geq 0, 0 \leq m \leq n \]" src="../../form_127.png"/>
</p>
<p> in which <img class="formulaInl" alt="$ P_{ n, m }( u ) $" src="../../form_128.png"/> is the ordinary Legendre polynomial with degree <img class="formulaInl" alt="$ n $" src="../../form_12.png"/>, order <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> and polynomial parameter <img class="formulaInl" alt="$ u $" src="../../form_126.png"/>.</p>
<p>For <img class="formulaInl" alt="$ n \geq 0, m \geq n $" src="../../form_129.png"/> the <img class="formulaInl" alt="$ P _{ n, m }( u ) $" src="../../form_125.png"/> has been defined here as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P _{ n, m } ( u ) = 0 \textrm{ for }n \geq 0, m \geq n \]" src="../../form_130.png"/>
</p>
<p>This function has been optimized for repeated calls with varying 'degree' and 'order' arguments (but with identical 'polynomialParameter' argument). To this end the function maintains a back-end cache with intermediate results which is automatically carried over between calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>Degree of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">order</td><td>Order of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">legendreCache</td><td>Legendre cache from which to retrieve Legendre polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unnormalized Legendre polynomial. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00310">310</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>References <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00709">computeLegendrePolynomialDiagonal()</a>, <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00552">computeLegendrePolynomialExplicit()</a>, <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00731">computeLegendrePolynomialVertical()</a>, <a class="el" href="../../db/d81/legendre_polynomials_8h_source.html#l00097">tudat::basic_mathematics::LegendreCache::getCurrentPolynomialParameter()</a>, <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00234">tudat::basic_mathematics::LegendreCache::getLegendrePolynomial()</a>, and <a class="el" href="../../db/d81/legendre_polynomials_8h_source.html#l00164">tudat::basic_mathematics::LegendreCache::getUseGeodesyNormalization()</a>.</p>

<p>Referenced by <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00382">computeLegendrePolynomial()</a>.</p>

</div>
</div>
<a class="anchor" id="a410e8dd4001c35b34fb1505f78b6fda6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::computeLegendrePolynomial </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>legendreParameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns an unnormalized associated Legendre polynomial <img class="formulaInl" alt="$ P _{ n, m }( u ) $" src="../../form_125.png"/> with degree <img class="formulaInl" alt="$ n $" src="../../form_12.png"/>, order <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> and polynomial parameter <img class="formulaInl" alt="$ u $" src="../../form_126.png"/>. <img class="formulaInl" alt="$ P _{ n, m }( u ) $" src="../../form_125.png"/> obeys the definition given by Vallado [2001]: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P _{ n, m } ( u ) = ( 1 - u ^ 2 ) ^ { m / 2 } \frac{ d ^ m }{ du ^ m } \left[ P_n ( u ) \right] \textrm{ for }n \geq 0, 0 \leq m \leq n \]" src="../../form_127.png"/>
</p>
<p> in which <img class="formulaInl" alt="$ P_{ n, m }( u ) $" src="../../form_128.png"/> is the ordinary Legendre polynomial with degree <img class="formulaInl" alt="$ n $" src="../../form_12.png"/>, order <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> and polynomial parameter <img class="formulaInl" alt="$ u $" src="../../form_126.png"/>.</p>
<p>For <img class="formulaInl" alt="$ n \geq 0, m \geq n $" src="../../form_129.png"/> the <img class="formulaInl" alt="$ P _{ n, m }( u ) $" src="../../form_125.png"/> has been defined here as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P _{ n, m } ( u ) = 0 \textrm{ for }n \geq 0, m \geq n \]" src="../../form_130.png"/>
</p>
<p>This function has been optimized for repeated calls with varying 'degree' and 'order' arguments (but with identical 'polynomialParameter' argument). To this end the function maintains a back-end cache with intermediate results which is automatically carried over between calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>Degree of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">order</td><td>Order of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">legendreParameter</td><td>Free variable of requested Legendre polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unnormalized Legendre polynomial. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00382">382</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>References <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00310">computeLegendrePolynomialFromCache()</a>, and <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00065">tudat::basic_mathematics::LegendreCache::update()</a>.</p>

</div>
</div>
<a class="anchor" id="a16c6b72f4a30ea76e48b11f72e3f7f6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::computeGeodesyLegendrePolynomialFromCache </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d1f/classtudat_1_1basic__mathematics_1_1_legendre_cache.html">LegendreCache</a> &amp;&#160;</td>
          <td class="paramname"><em>geodesyLegendreCache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a normalized associated Legendre polynomial <img class="formulaInl" alt="$ \bar{ P }_{ n, m }( u ) $" src="../../form_131.png"/> with degree <img class="formulaInl" alt="$ n $" src="../../form_12.png"/>, order <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> and polynomial parameter <img class="formulaInl" alt="$ u $" src="../../form_126.png"/>. The normalization obeys the definition: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bar{ P }_{ n, m } ( u ) = \Pi_{ n, m } P_{ n, m } ( u ) \]" src="../../form_132.png"/>
</p>
<p> in which <img class="formulaInl" alt="$ \Pi_{ n, m } $" src="../../form_62.png"/> is the normalization factor which is commonly used in geodesy and is given by Heiskanen &amp; Moritz [1967] as: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Pi_{ n, m } = \sqrt{ \frac{ ( 2 - \delta_{ 0, m } ) ( 2 n + 1 ) ( n - m )! } { ( n + m )! } } \]" src="../../form_133.png"/>
</p>
<p> in which <img class="formulaInl" alt="$ n $" src="../../form_12.png"/> is the degree, <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> is the order and <img class="formulaInl" alt="$ \delta_{ 0, m } $" src="../../form_64.png"/> is the Kronecker delta.</p>
<p><img class="formulaInl" alt="$ P _{ n, m }( u ) $" src="../../form_125.png"/> obeys the definition given by Vallado [2001]: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P _{ n, m } ( u ) = ( 1 - u ^ 2 ) ^ { m / 2 } \frac{ d ^ m }{ du ^ m } \left[ P_n ( u ) \right] \]" src="../../form_134.png"/>
</p>
<p> in which <img class="formulaInl" alt="$ P_{ n, m }( u ) $" src="../../form_128.png"/> is the ordinary Legendre polynomial with degree <img class="formulaInl" alt="$ n $" src="../../form_12.png"/>, order <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> and polynomial parameter <img class="formulaInl" alt="$ u $" src="../../form_126.png"/>.</p>
<p>For <img class="formulaInl" alt="$ n \geq 0, m \geq n $" src="../../form_129.png"/> the <img class="formulaInl" alt="$ P _{ n, m }( u ) $" src="../../form_125.png"/> has been defined here as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P _{ n, m } ( u ) = 0 \textrm{ for }n \geq 0, m \geq n \]" src="../../form_130.png"/>
</p>
<p>This function has been optimized for repeated calls with varying 'degree' and 'order' arguments (but with identical 'polynomialParameter' argument). To this end the function maintains a back-end cache with intermediate results which is automatically carried over between calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>Degree of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">order</td><td>Order of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">geodesyLegendreCache</td><td>Legendre cache from which to retrieve Legendre polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Geodesy-normalized Legendre polynomial. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00393">393</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>References <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00720">computeGeodesyLegendrePolynomialDiagonal()</a>, <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00673">computeGeodesyLegendrePolynomialExplicit()</a>, <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00744">computeGeodesyLegendrePolynomialVertical()</a>, <a class="el" href="../../db/d81/legendre_polynomials_8h_source.html#l00097">tudat::basic_mathematics::LegendreCache::getCurrentPolynomialParameter()</a>, <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00234">tudat::basic_mathematics::LegendreCache::getLegendrePolynomial()</a>, and <a class="el" href="../../db/d81/legendre_polynomials_8h_source.html#l00164">tudat::basic_mathematics::LegendreCache::getUseGeodesyNormalization()</a>.</p>

<p>Referenced by <a class="el" href="../../d5/ddd/spherical_harmonics_gravity_field_8cpp_source.html#l00027">tudat::gravitation::calculateSphericalHarmonicGravitationalPotential()</a>, and <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00466">computeGeodesyLegendrePolynomial()</a>.</p>

</div>
</div>
<a class="anchor" id="aad517ca542d264b6a7d33abbf027798e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::computeGeodesyLegendrePolynomial </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>legendreParameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a normalized associated Legendre polynomial <img class="formulaInl" alt="$ \bar{ P }_{ n, m }( u ) $" src="../../form_131.png"/> with degree <img class="formulaInl" alt="$ n $" src="../../form_12.png"/>, order <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> and polynomial parameter <img class="formulaInl" alt="$ u $" src="../../form_126.png"/>. The normalization obeys the definition: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bar{ P }_{ n, m } ( u ) = \Pi_{ n, m } P_{ n, m } ( u ) \]" src="../../form_132.png"/>
</p>
<p> in which <img class="formulaInl" alt="$ \Pi_{ n, m } $" src="../../form_62.png"/> is the normalization factor which is commonly used in geodesy and is given by Heiskanen &amp; Moritz [1967] as: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Pi_{ n, m } = \sqrt{ \frac{ ( 2 - \delta_{ 0, m } ) ( 2 n + 1 ) ( n - m )! } { ( n + m )! } } \]" src="../../form_133.png"/>
</p>
<p> in which <img class="formulaInl" alt="$ n $" src="../../form_12.png"/> is the degree, <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> is the order and <img class="formulaInl" alt="$ \delta_{ 0, m } $" src="../../form_64.png"/> is the Kronecker delta.</p>
<p><img class="formulaInl" alt="$ P _{ n, m }( u ) $" src="../../form_125.png"/> obeys the definition given by Vallado [2001]: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P _{ n, m } ( u ) = ( 1 - u ^ 2 ) ^ { m / 2 } \frac{ d ^ m }{ du ^ m } \left[ P_n ( u ) \right] \]" src="../../form_134.png"/>
</p>
<p> in which <img class="formulaInl" alt="$ P_{ n, m }( u ) $" src="../../form_128.png"/> is the ordinary Legendre polynomial with degree <img class="formulaInl" alt="$ n $" src="../../form_12.png"/>, order <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> and polynomial parameter <img class="formulaInl" alt="$ u $" src="../../form_126.png"/>.</p>
<p>For <img class="formulaInl" alt="$ n \geq 0, m \geq n $" src="../../form_129.png"/> the <img class="formulaInl" alt="$ P _{ n, m }( u ) $" src="../../form_125.png"/> has been defined here as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P _{ n, m } ( u ) = 0 \textrm{ for }n \geq 0, m \geq n \]" src="../../form_130.png"/>
</p>
<p>This function has been optimized for repeated calls with varying 'degree' and 'order' arguments (but with identical 'polynomialParameter' argument). To this end the function maintains a back-end cache with intermediate results which is automatically carried over between calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>Degree of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">order</td><td>Order of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">legendreParameter</td><td>Free variable of requested Legendre polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Geodesy-normalized Legendre polynomial. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00466">466</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>References <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00393">computeGeodesyLegendrePolynomialFromCache()</a>, and <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00065">tudat::basic_mathematics::LegendreCache::update()</a>.</p>

</div>
</div>
<a class="anchor" id="a28f9ea0c3e6f1c496774db4168111613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::computeLegendrePolynomialDerivative </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>polynomialParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>currentLegendrePolynomial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>incrementedLegendrePolynomial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The derivative is computed as: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{ \mathrm{ d } P_{ n, m } ( u ) }{ \mathrm{ d } u } = \frac{ \sqrt{ 1 - u ^ 2 } P_{ n, m + 1 }( u ) - m u P_{ n, m }( u ) }{ 1 - u ^ 2 } \]" src="../../form_135.png"/>
</p>
<p> in which <img class="formulaInl" alt="$ n $" src="../../form_12.png"/> is the degree, <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> is the order, <img class="formulaInl" alt="$ u $" src="../../form_126.png"/> is the polynomial parameter, <img class="formulaInl" alt="$ P_{ n, m } ( u ) $" src="../../form_136.png"/> is an associated Legendre polynomial, and <img class="formulaInl" alt="$ P_{ n, m + 1 } ( u ) $" src="../../form_137.png"/> is an associated Legendre polynomial. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Order of requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">polynomialParameter</td><td>Free variable of requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">currentLegendrePolynomial</td><td>Unnormalized Legendre polynomial with the same degree, order and polynomial parameter as the requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">incrementedLegendrePolynomial</td><td>Unnormalized Legendre polynomial with the same degree and polynomial parameter as the requested Legendre polynomial derivative, but with an order of one more. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unnormalized Legendre polynomial derivative with respect to the polynomial parameter. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00476">476</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>Referenced by <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00065">tudat::basic_mathematics::LegendreCache::update()</a>.</p>

</div>
</div>
<a class="anchor" id="ab192c93cfab1232132719a683d6ae688"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::computeGeodesyLegendrePolynomialDerivative </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>polynomialParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>currentLegendrePolynomial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>incrementedLegendrePolynomial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>normalizationCorrection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute derivative of geodesy-normalized associated Legendre polynomial.</p>
<p>Compute derivative of geodesy-normalized associated Legendre polynomial. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>Degree of requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">order</td><td>Order of requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">polynomialParameter</td><td>Free variable of requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">currentLegendrePolynomial</td><td>Geodesy-normalized Legendre polynomial with the same degree, order and polynomial parameter as the requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">incrementedLegendrePolynomial</td><td>Geodesy-normalized Legendre polynomial with the same degree and polynomial parameter as the requested Legendre polynomial derivative, but with an order of one more. </td></tr>
    <tr><td class="paramname">normalizationCorrection</td><td>Pre-computed scaling term used for part of computations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Geodesy-normalized Legendre polynomial derivative with respect to the polynomial parameter. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00490">490</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>Referenced by <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00506">computeGeodesyLegendrePolynomialDerivative()</a>, and <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00065">tudat::basic_mathematics::LegendreCache::update()</a>.</p>

</div>
</div>
<a class="anchor" id="a85094d571a57ad3ad94173224aa33b55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::computeGeodesyLegendrePolynomialDerivative </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>polynomialParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>currentLegendrePolynomial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>incrementedLegendrePolynomial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The derivative is computed as: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{ \mathrm{ d } \bar{ P }_{ n, m } ( u ) }{ \mathrm{ d } u } = \sqrt{ \frac{ ( n + m + 1 )( n - m ) }{ ( 1 + \delta_{ 0, m } ) ( 1 - u^2 ) } } \bar{ P }_{ n, m + 1 } - \frac{ m u }{ 1 - u^2 } \bar{ P }_{ n, m } \]" src="../../form_138.png"/>
</p>
<p> in which <img class="formulaInl" alt="$ n $" src="../../form_12.png"/> is the degree, <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> is the order, <img class="formulaInl" alt="$ u $" src="../../form_126.png"/> is the polynomial parameter, <img class="formulaInl" alt="$ \delta_{ 0, m } $" src="../../form_64.png"/> is the Kronecker delta, <img class="formulaInl" alt="$ P_{ n, m } ( u ) $" src="../../form_136.png"/> is an associated Legendre polynomial, and <img class="formulaInl" alt="$ P_{ n, m + 1 } ( u ) $" src="../../form_137.png"/> is an associated Legendre polynomial. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>Degree of requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">order</td><td>Order of requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">polynomialParameter</td><td>Free variable of requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">currentLegendrePolynomial</td><td>Geodesy-normalized Legendre polynomial with the same degree, order and polynomial parameter as the requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">incrementedLegendrePolynomial</td><td>Geodesy-normalized Legendre polynomial with the same degree and polynomial parameter as the requested Legendre polynomial derivative, but with an order of one more. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Geodesy-normalized Legendre polynomial derivative with respect to the polynomial parameter. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00506">506</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>References <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00490">computeGeodesyLegendrePolynomialDerivative()</a>.</p>

</div>
</div>
<a class="anchor" id="a0bdf97455465f9cbf9fdc348c7969f49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::computeGeodesyLegendrePolynomialSecondDerivative </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>polynomialParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>currentLegendrePolynomial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>incrementedLegendrePolynomial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>currentLegendrePolynomialDerivative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>incrementedLegendrePolynomialDerivative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>normalizationCorrection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute second derivative of geodesy-normalized associated Legendre polynomial. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>Degree of requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">order</td><td>Order of requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">polynomialParameter</td><td>Free variable of requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">currentLegendrePolynomial</td><td>Geodesy-normalized Legendre polynomial with the same degree, order and polynomial parameter as the requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">incrementedLegendrePolynomial</td><td>Geodesy-normalized Legendre polynomial with the same degree and polynomial parameter as the requested Legendre polynomial derivative, but with an order of one more. </td></tr>
    <tr><td class="paramname">currentLegendrePolynomialDerivative</td><td>Geodesy-normalized derivative of Legendre polynomial with the same degree, order and polynomial parameter as the requested Legendre polynomial derivative. </td></tr>
    <tr><td class="paramname">incrementedLegendrePolynomialDerivative</td><td>Geodesy-normalized derivative of Legendre polynomial with the same degree and polynomial parameter as the requested Legendre polynomial derivative, but with an order of one more. </td></tr>
    <tr><td class="paramname">normalizationCorrection</td><td>Pre-computed scaling term used for part of computations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Geodesy-normalized Legendre polynomial derivative with respect to the polynomial parameter. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00530">530</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>Referenced by <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00065">tudat::basic_mathematics::LegendreCache::update()</a>.</p>

</div>
</div>
<a class="anchor" id="a42836ef41e0dd05b2a7f6d9796223a1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::computeLegendrePolynomialExplicit </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>polynomialParameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The associated Legendre polynomial <img class="formulaInl" alt="$ P_{ n, m }(u) $" src="../../form_139.png"/> with degree <img class="formulaInl" alt="$ n $" src="../../form_12.png"/>, order <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> and polynomial parameter <img class="formulaInl" alt="$ u $" src="../../form_126.png"/> is calculated using explicit formulas given by Eberly [2008]: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} P_{ 0, 0 }( u ) = 1 \\ P_{ 1, 0 }( u ) = u \\ P_{ 1, 1 }( u ) = \sqrt{ 1 - u^2 } \end{eqnarray*}" src="../../form_140.png"/>
</p>
<p> Calculation up to <img class="formulaInl" alt="$ n = 1 $" src="../../form_141.png"/> and <img class="formulaInl" alt="$ m = 1 $" src="../../form_142.png"/> is supported by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>Degree of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">order</td><td>Order of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">polynomialParameter</td><td>Free variable of requested Legendre polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unnormalized Legendre polynomial. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00552">552</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>References <a class="el" href="../../d6/d70/mathematical_constants_8h_source.html#l00076">TUDAT_NAN</a>.</p>

<p>Referenced by <a class="el" href="../../d9/d20/tidal_love_number_partial_interface_8cpp_source.html#l00321">tudat::orbit_determination::TidalLoveNumberPartialInterface::calculateCoefficientPartialWrtRealTidalLoveNumber()</a>, <a class="el" href="../../d0/db9/basic_solid_body_tide_gravity_field_variations_8cpp_source.html#l00073">tudat::gravitation::calculateSolidBodyTideSingleCoefficientSetCorrectionFromAmplitude()</a>, <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00310">computeLegendrePolynomialFromCache()</a>, and <a class="el" href="../../df/d9d/basic_solid_body_tide_gravity_field_variations_8h_source.html#l00431">tudat::gravitation::BasicSolidBodyTideGravityFieldVariations::updateTidalAmplitudeAndArgument()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2f3dbf703116044abad0da08ca7a870"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::computeGeodesyLegendrePolynomialExplicit </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>polynomialParameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute low degree/order geodesy-normalized Legendre polynomial explicitly.</p>
<p>The normalized associated Legendre polynomial <img class="formulaInl" alt="$ \bar{ P }_{ n, m }(u) $" src="../../form_143.png"/> with degree <img class="formulaInl" alt="$ n $" src="../../form_12.png"/>, order <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> and polynomial parameter <img class="formulaInl" alt="$ u $" src="../../form_126.png"/> is calculated using explicit formulas: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \bar{ P }_{ 0, 0 }( u ) = 1 \\ \bar{ P }_{ 1, 0 }( u ) = \sqrt{ 3 } u \\ \bar{ P }_{ 1, 1 }( u ) = \sqrt{ 3 - 3 u^2 } \end{eqnarray*}" src="../../form_144.png"/>
</p>
<p> Calculation up to <img class="formulaInl" alt="$ n = 1 $" src="../../form_141.png"/> and <img class="formulaInl" alt="$ m = 1 $" src="../../form_142.png"/> is supported by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>Degree of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">order</td><td>Order of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">polynomialParameter</td><td>Free variable of requested Legendre polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Geodesy-normalized Legendre polynomial. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00673">673</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>Referenced by <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00393">computeGeodesyLegendrePolynomialFromCache()</a>.</p>

</div>
</div>
<a class="anchor" id="a043b86135da3bd5ce68bbd5d3500f4d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::computeLegendrePolynomialDiagonal </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>degreeOneOrderOnePolynomial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>priorSectoralPolynomial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The associated Legendre polynomial <img class="formulaInl" alt="$ P_{ n, m }( u ) $" src="../../form_128.png"/> with degree <img class="formulaInl" alt="$ n $" src="../../form_12.png"/>, order <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> and polynomial parameter <img class="formulaInl" alt="$ u $" src="../../form_126.png"/> is calculated through degree recursion as given by Vallado [2001]: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P_{ n, m }( u ) = ( 2 n - 1 ) P_{ 1, 1 }( u ) P_{ n - 1, m - 1 }( u ) \]" src="../../form_145.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>Degree of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">degreeOneOrderOnePolynomial</td><td>Unnormalized Legendre polynomial with the same polynomial parameter as the requested Legendre polynomial, but with a degree and order of one. </td></tr>
    <tr><td class="paramname">priorSectoralPolynomial</td><td>Unnormalized Legendre polynomial with the same polynomial parameter as the requested Legendre polynomial, but with a degree and order of one less. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unnormalized Legendre polynomial. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00709">709</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>Referenced by <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00310">computeLegendrePolynomialFromCache()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c8db058213b11d973862d8d6c2841a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::computeGeodesyLegendrePolynomialDiagonal </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>degreeOneOrderOnePolynomial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>priorSectoralPolynomial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The associated Legendre polynomial <img class="formulaInl" alt="$ P_{ n, m }( u ) $" src="../../form_128.png"/> with degree <img class="formulaInl" alt="$ n $" src="../../form_12.png"/>, order <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> and polynomial parameter <img class="formulaInl" alt="$ u $" src="../../form_126.png"/> is calculated through degree recursion as given by Holmes &amp; Featherstone [2002]: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bar{ P }_{ n, m }( u ) = \sqrt{ \frac{ 2 n - 1 }{ 6 n } } \bar{ P }_{ 1, 1 }( u ) \bar{ P }_{ n - 1, m - 1 }( u ) \]" src="../../form_146.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>Degree of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">degreeOneOrderOnePolynomial</td><td>Unnormalized Legendre polynomial with the same polynomial parameter as the requested Legendre polynomial, but with a degree and order of one. </td></tr>
    <tr><td class="paramname">priorSectoralPolynomial</td><td>Legendre polynomial with the same polynomial parameter as the requested Legendre polynomial, but with a degree and order of one less. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Geodesy-normalized Legendre polynomial. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00720">720</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>Referenced by <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00393">computeGeodesyLegendrePolynomialFromCache()</a>.</p>

</div>
</div>
<a class="anchor" id="a6fce33bb9876f706aae0674b399d41ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::computeLegendrePolynomialVertical </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>polynomialParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>oneDegreePriorPolynomial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>twoDegreesPriorPolynomial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The associated Legendre polynomial <img class="formulaInl" alt="$ P_{ n, m }( u ) $" src="../../form_128.png"/> with degree <img class="formulaInl" alt="$ n $" src="../../form_12.png"/>, order <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> and polynomial parameter <img class="formulaInl" alt="$ u $" src="../../form_126.png"/> is calculated through degree recursion as given by Weisstein [2012]: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P_{ n, m }( u ) = \frac{ ( 2 n - 1 ) u P_{ n - 1, m }( u ) - ( n + m - 1 ) P_{ n - 2, m }( u ) }{ n - m } \]" src="../../form_147.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>Degree of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">order</td><td>Order of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">polynomialParameter</td><td>Free variable of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">oneDegreePriorPolynomial</td><td>Unnormalized Legendre polynomial with the same order and polynomial parameter as the requested Legendre polynomial, but with a degree of one less. </td></tr>
    <tr><td class="paramname">twoDegreesPriorPolynomial</td><td>Geodesy-normalized Legendre polynomial with the same order and polynomial parameter as the requested Legendre polynomial, but with a degree of two less. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unnormalized Legendre polynomial. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00731">731</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>Referenced by <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00310">computeLegendrePolynomialFromCache()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d3ab08d7ccfd21e8ca3cc0b92587b59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::computeGeodesyLegendrePolynomialVertical </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>polynomialParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>oneDegreePriorPolynomial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>twoDegreesPriorPolynomial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The normalized associated Legendre polynomial <img class="formulaInl" alt="$ \bar{ P }_{ n, m }( u ) $" src="../../form_131.png"/> with degree <img class="formulaInl" alt="$ n $" src="../../form_12.png"/>, order <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> and polynomial parameter <img class="formulaInl" alt="$ u $" src="../../form_126.png"/> is calculated through degree recursion as given by Holmes &amp; Featherstone [2002]: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bar{ P }_{ n, m }( u ) = \sqrt{ \frac{ ( 2 n - 1 )( 2 n + 1 ) }{ ( n - m ) ( n + m ) } } u \bar{ P }_{ n - 1, m }( u ) - \sqrt{ \frac{ ( 2 n + 1 )( n + m - 1 ) ( n - m - 1 ) } { ( n - m)( n + m )( 2 n - 3 ) } } \bar{ P }_{ n - 2, m }( u ) \]" src="../../form_148.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>Degree of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">order</td><td>Order of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">polynomialParameter</td><td>Free variable of requested Legendre polynomial. </td></tr>
    <tr><td class="paramname">oneDegreePriorPolynomial</td><td>Geodesy-normalized Legendre polynomial with the same polynomial parameter as the requested Legendre polynomial, but with a degree of one less. </td></tr>
    <tr><td class="paramname">twoDegreesPriorPolynomial</td><td>Geodesy-normalized Legendre polynomial with the same polynomial parameter as the requested Legendre polynomial, but with a degree of two less. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Geodesy-normalized Legendre polynomial. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00744">744</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>Referenced by <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00393">computeGeodesyLegendrePolynomialFromCache()</a>.</p>

</div>
</div>
<a class="anchor" id="a36972723d016b7db39d92ccdc018cc0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::basic_mathematics::calculateLegendreGeodesyNormalizationFactor </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="../../d0/d9b/classtudat_1_1basic__mathematics_1_1_function.html" title="Function interface to allow evaluation of a mathematical function. ">Function</a> to calculate the normalization factor K_nm to convert regular Legendre polynomials P_nm to geodesy-normalized Legendre polynomials bar{P}_nm, so that bar{P}_nm=K_nm*P_nm. Note that the same conversion for spherical harmonic coefficients from regular to geodesy- normalized requires the inverse factor: 1/K_nm: C_nm=K_nm* bar{C}_nm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>Degree of Legendre polynomial </td></tr>
    <tr><td class="paramname">order</td><td>Order of Legendre polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Normalization factor K_nm </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00761">761</a> of file <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html">legendrePolynomials.cpp</a>.</p>

<p>Referenced by <a class="el" href="../../d0/db9/basic_solid_body_tide_gravity_field_variations_8cpp_source.html#l00058">tudat::gravitation::calculateSolidBodyTideSingleCoefficientSetCorrectionFromAmplitude()</a>, and <a class="el" href="../../d5/da3/tri_axial_ellipsoid_gravity_8cpp_source.html#l00134">tudat::gravitation::createTriAxialEllipsoidNormalizedSphericalHarmonicCoefficients()</a>.</p>

</div>
</div>
<a class="anchor" id="a0338c727149f283911719894d6ed44c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tudat::basic_mathematics::computeNearestLeftNeighborUsingBinarySearch </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vectorOfSortedData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>targetValueInVectorOfSortedData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for the nearest left neighbor in a vector of sorted data using a binary algorithm (Press W.H., et al., 2002). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectorOfSortedData</td><td>Vector of data sorted in ascending/descending order. </td></tr>
    <tr><td class="paramname">targetValueInVectorOfSortedData</td><td>Target value in vector of sorted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of nearest left neighbor to target value. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d09/nearest_neighbour_search_8cpp_source.html#l00029">29</a> of file <a class="el" href="../../de/d09/nearest_neighbour_search_8cpp_source.html">nearestNeighbourSearch.cpp</a>.</p>

<p>Referenced by <a class="el" href="../../d4/da2/linear_interpolator_8cpp_source.html#l00026">tudat::interpolators::computeLinearInterpolation()</a>, <a class="el" href="../../d4/dd5/lookup_scheme_8h_source.html#l00120">tudat::interpolators::HuntingAlgorithmLookupScheme&lt; IndependentVariableType &gt;::findNearestLowerNeighbour()</a>, and <a class="el" href="../../d4/dd5/lookup_scheme_8h_source.html#l00209">tudat::interpolators::BinarySearchLookupScheme&lt; IndependentVariableType &gt;::findNearestLowerNeighbour()</a>.</p>

</div>
</div>
<a class="anchor" id="a623b22dbb2ba19fb45991c82fd76c9e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tudat::basic_mathematics::computeNearestNeighborUsingBinarySearch </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vectorOfSortedData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>targetValueInVectorOfSortedData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for the nearest neighbor in a vector of sorted data using a binary algorithm (Press W.H., et al., 2002). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectorOfSortedData</td><td>Vector of data sorted in ascending/descending order. </td></tr>
    <tr><td class="paramname">targetValueInVectorOfSortedData</td><td>Target value in vector of sorted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of nearest neighbor to target value. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d09/nearest_neighbour_search_8cpp_source.html#l00080">80</a> of file <a class="el" href="../../de/d09/nearest_neighbour_search_8cpp_source.html">nearestNeighbourSearch.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a967e6cb5f0b7b4e05bdf1bd9e8577f05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tudat::basic_mathematics::computeNearestLeftNeighborUsingBinarySearch </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; double, Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>sortedIndepedentAndDependentVariables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>targetValueInMapOfData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for the nearest left neighbor in a map of sorted data using a binary algorithm (Press W.H., et al., 2002). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sortedIndepedentAndDependentVariables</td><td>Map of independent and dependent data sorted in ascending/descending order. </td></tr>
    <tr><td class="paramname">targetValueInMapOfData</td><td>Target value in map of sorted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of nearest left neighbor to target value. </dd></dl>

<p>Definition at line <a class="el" href="../../de/d09/nearest_neighbour_search_8cpp_source.html#l00141">141</a> of file <a class="el" href="../../de/d09/nearest_neighbour_search_8cpp_source.html">nearestNeighbourSearch.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3629b671b410d55e7d4346d2b40ed122"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndependentVariableType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int tudat::basic_mathematics::computeNearestLeftNeighborUsingBinarySearch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IndependentVariableType &gt;&#160;</td>
          <td class="paramname"><em>vectorOfSortedData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndependentVariableType&#160;</td>
          <td class="paramname"><em>targetValueInVectorOfSortedData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Templated nearest left neighbor binary search. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndependentVariableType</td><td>Type of independent variables in which search is to be done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectorOfSortedData</td><td>STL vector, sorted in ascending order, containing independent variable values. </td></tr>
    <tr><td class="paramname">targetValueInVectorOfSortedData</td><td>Value of independent variable of which the nearest left neighbour is to be determined. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d8/dec/nearest_neighbour_search_8h_source.html#l00075">75</a> of file <a class="el" href="../../d8/dec/nearest_neighbour_search_8h_source.html">nearestNeighbourSearch.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab485a5660b41a17e0fe33e945d16bda7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndependentVariableType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tudat::basic_mathematics::isIndependentVariableInInterval </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lowerIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndependentVariableType&#160;</td>
          <td class="paramname"><em>independentVariableValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; IndependentVariableType &gt; &amp;&#160;</td>
          <td class="paramname"><em>independentValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks whether a value is in a given interval of an STL vector, sorted in ascending order of value of the entries. The interval is identified by the lower index of the entries of the vector defining the interval. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndependentVariableType</td><td>Type of the independent variable values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lowerIndex</td><td>Index of lower bound of interval under consideration. </td></tr>
    <tr><td class="paramname">independentVariableValue</td><td>Value of which it is to be checked whether it is in the interval. </td></tr>
    <tr><td class="paramname">independentValues</td><td>Vector of values, srted in ascending order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if value is in interval, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="../../d8/dec/nearest_neighbour_search_8h_source.html#l00138">138</a> of file <a class="el" href="../../d8/dec/nearest_neighbour_search_8h_source.html">nearestNeighbourSearch.h</a>.</p>

</div>
</div>
<a class="anchor" id="a20a2a1955501e2a3aa7a25768ae5e599"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndependentVariableType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int tudat::basic_mathematics::findNearestLeftNeighbourUsingHuntingAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const IndependentVariableType&#160;</td>
          <td class="paramname"><em>independentVariableValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>previousNearestLowerIndex_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; IndependentVariableType &gt; &amp;&#160;</td>
          <td class="paramname"><em>independentValues_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nearest left leighbour search using hunting algorithm, using an initial guess to decrease the look-up time. Especially useful for long data vectors where the value for which the nearest neighbour is to be found changes slowly w.r.t. the data entries. Implementation is taken from (Press W.H., et al., 2002). Algorithm is at worst twice as slow as binary search and can be orders of magnitude faster in suitable cases. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndependentVariableType</td><td>Type for entries of vector of in which nearest neighbour is sought. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">independentVariableValue</td><td>Value of which the nearest left neighbour is to be calculated. </td></tr>
    <tr><td class="paramname">previousNearestLowerIndex_</td><td>Initial guess of nearest lft neighbour. </td></tr>
    <tr><td class="paramname">independentValues_</td><td>Vector of independent variables, sorted in ascending order, in which the nearest left (lower) neighbour is to be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of independentValues_ that is the nearest left neighbour </dd></dl>

<p>Definition at line <a class="el" href="../../d8/dec/nearest_neighbour_search_8h_source.html#l00170">170</a> of file <a class="el" href="../../d8/dec/nearest_neighbour_search_8h_source.html">nearestNeighbourSearch.h</a>.</p>

<p>Referenced by <a class="el" href="../../d4/dd5/lookup_scheme_8h_source.html#l00120">tudat::interpolators::HuntingAlgorithmLookupScheme&lt; IndependentVariableType &gt;::findNearestLowerNeighbour()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e01a3523a4a296e577f3e95ae1c2014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tudat::basic_mathematics::computeRotationOfPointAboutArbitraryAxis </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>originOfRotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>angleOfRotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>axisOfRotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>initialPositionOfPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the rotation of a point about an arbitrary axis. This function computes the position of the rotated point by computing the displacement vector between the origin of rotation and the initalPosition of point and then applying a matrix as shown in section 6 of <a href="http://inside.mines.edu/~gmurray/ArbitraryAxisRotation/ArbitraryAxisRotation.html">http://inside.mines.edu/~gmurray/ArbitraryAxisRotation/ArbitraryAxisRotation.html</a>. A visualization of the computation being performed can be found at <a href="http://twist-and-shout.appspot.com/">http://twist-and-shout.appspot.com/</a>. Units for originOfRotation, and initialPositionOfPoint must be the same. All positions are assumed to be with respect to a common arbitrary origin. Note that this arbitrary origin is not necessarily the origin of rotation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originOfRotation</td><td>Position of tail of axis of rotation vector with respect to a chosen arbitrary origin. </td></tr>
    <tr><td class="paramname">angleOfRotation</td><td>Angle about which the point rotates with respect to the axis of rotation [rad]. </td></tr>
    <tr><td class="paramname">axisOfRotation</td><td>Unit vector pointed in the direction of rotation determined by the right-hand rule. </td></tr>
    <tr><td class="paramname">initialPositionOfPoint</td><td>Position of point before rotation with respect to the same chosen arbitrary origin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of point after rotation about the axis of rotation with respect to the same chosen arbitrary origin. </dd></dl>

<p>Definition at line <a class="el" href="../../d6/dac/rotation_about_arbitrary_axis_8cpp_source.html#l00027">27</a> of file <a class="el" href="../../d6/dac/rotation_about_arbitrary_axis_8cpp_source.html">rotationAboutArbitraryAxis.cpp</a>.</p>

<p>Referenced by <a class="el" href="../../d6/dac/rotation_about_arbitrary_axis_8cpp_source.html#l00055">computeRotationOfVectorAboutArbitraryAxis()</a>.</p>

</div>
</div>
<a class="anchor" id="a54c62bb9afe019a4a061b8c40ad1f55d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tudat::basic_mathematics::computeRotationOfVectorAboutArbitraryAxis </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>originOfRotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>angleOfRotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>axisOfRotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>initialPositionOfVectorTail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>initialVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute rotation of vector about an arbitrary axis.</p>
<p>Computes rotation of vector about an arbitrary axis. This function uses computeRotationOfPointAboutArbitraryAxis to rotate the position of the head and tail of the vector and compute the resultant vector defined as the difference of the two rotated points. Units for originOfRotation, initialPositionOfVectorTail and initialVector must be the same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originOfRotation</td><td>Position of tail of axis of rotation vector with respect to a chosen arbitrary origin. </td></tr>
    <tr><td class="paramname">angleOfRotation</td><td>Angle over which the vector is rotated. A positive angle is determined using the right hand rule [rad]. </td></tr>
    <tr><td class="paramname">axisOfRotation</td><td>Unit vector pointing in the direction of rotation determined by the right-hand rule. </td></tr>
    <tr><td class="paramname">initialPositionOfVectorTail</td><td>Initial position of tail of vector which will be rotated with respect to this same chosen arbitrary origin. </td></tr>
    <tr><td class="paramname">initialVector</td><td>Vector to be rotated with respect to this same chosen arbitrary origin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector after rotation about the arbitrary axis with respect to this same chosen arbitrary origin. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a4e01a3523a4a296e577f3e95ae1c2014" title="Compute rotation of point about arbitrary axis. ">computeRotationOfPointAboutArbitraryAxis</a>. </dd></dl>

<p>Definition at line <a class="el" href="../../d6/dac/rotation_about_arbitrary_axis_8cpp_source.html#l00055">55</a> of file <a class="el" href="../../d6/dac/rotation_about_arbitrary_axis_8cpp_source.html">rotationAboutArbitraryAxis.cpp</a>.</p>

<p>References <a class="el" href="../../d6/dac/rotation_about_arbitrary_axis_8cpp_source.html#l00027">computeRotationOfPointAboutArbitraryAxis()</a>.</p>

</div>
</div>
<a class="anchor" id="afe7d242d59760af59b348d3ce4064b18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tudat::basic_mathematics::computePotentialGradient </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>radiusPowerTerm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cosineOfOrderLongitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sineOfOrderLongitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cosineOfLatitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>preMultiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cosineHarmonicCoefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sineHarmonicCoefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>legendrePolynomial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>legendrePolynomialDerivative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a vector with the derivatives of a generic potential field (defined by spherical harmonics) from pre-computed quatities. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distance</td><td>Distance to center of body with gravity field at which the potential gradient is to be calculated </td></tr>
    <tr><td class="paramname">radiusPowerTerm</td><td>Distance divided by the reference radius of the gravity field, to the power (degree + 1) </td></tr>
    <tr><td class="paramname">cosineOfOrderLongitude</td><td>Cosine of order times the longitude at which the potential is to be calculated </td></tr>
    <tr><td class="paramname">sineOfOrderLongitude</td><td>Sine of order times the longitude at which the potential is to be calculated </td></tr>
    <tr><td class="paramname">cosineOfLatitude</td><td>Cosine of the latitude at which the potential is to be calculated </td></tr>
    <tr><td class="paramname">preMultiplier</td><td>Generic multiplication factor. </td></tr>
    <tr><td class="paramname">degree</td><td>Degree of the harmonic for which the gradient is to be computed. </td></tr>
    <tr><td class="paramname">order</td><td>Order of the harmonic for which the gradient is to be computed. </td></tr>
    <tr><td class="paramname">cosineHarmonicCoefficient</td><td>Coefficient which characterizes relative strengh of a harmonic term. </td></tr>
    <tr><td class="paramname">sineHarmonicCoefficient</td><td>Coefficient which characterizes relative strengh of a harmonic term. </td></tr>
    <tr><td class="paramname">legendrePolynomial</td><td>Value of associated Legendre polynomial with the same degree and order as the to be computed harmonic, and with the sine of the latitude coordinate as polynomial parameter. Make sure that the Legendre polynomial has the same normalization as the harmonic coefficients. </td></tr>
    <tr><td class="paramname">legendrePolynomialDerivative</td><td>Value of the derivative of parameter 'legendrePolynomial' with respect to the sine of the latitude angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with derivatives of potential field. The order is important! gradient( 0 ) = derivative with respect to radial distance, gradient( 1 ) = derivative with respect to latitude angle, gradient( 2 ) = derivative with respect to longitude angle. </dd></dl>

<p>Definition at line <a class="el" href="../../da/d06/spherical_harmonics_8cpp_source.html#l00043">43</a> of file <a class="el" href="../../da/d06/spherical_harmonics_8cpp_source.html">sphericalHarmonics.cpp</a>.</p>

<p>Referenced by <a class="el" href="../../d6/d71/spherical_harmonic_partial_functions_8cpp_source.html#l00213">tudat::acceleration_partials::calculateSphericalHarmonicGravityWrtCCoefficients()</a>, <a class="el" href="../../d6/d71/spherical_harmonic_partial_functions_8cpp_source.html#l00251">tudat::acceleration_partials::calculateSphericalHarmonicGravityWrtSCoefficients()</a>, <a class="el" href="../../db/dc4/spherical_harmonics_gravity_model_8cpp_source.html#l00037">tudat::gravitation::computeGeodesyNormalizedGravitationalAccelerationSum()</a>, <a class="el" href="../../da/d06/spherical_harmonics_8cpp_source.html#l00075">computePotentialGradient()</a>, and <a class="el" href="../../db/dc4/spherical_harmonics_gravity_model_8cpp_source.html#l00105">tudat::gravitation::computeSingleGeodesyNormalizedGravitationalAcceleration()</a>.</p>

</div>
</div>
<a class="anchor" id="ae93695b85b89b0120ca8b2d63e758e9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tudat::basic_mathematics::computePotentialGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>sphericalPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>referenceRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>preMultiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cosineHarmonicCoefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sineHarmonicCoefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>legendrePolynomial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>legendrePolynomialDerivative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a vector with the derivatives of a generic potential field (defined by spherical harmonics). * </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sphericalPosition</td><td>Vector with spherical coordinates. The order is important! sphericalPosition( 0 ) = radial coordinate, sphericalPosition( 1 ) = latitude coordinate, sphericalPosition( 2 ) = longitude coordinate. </td></tr>
    <tr><td class="paramname">referenceRadius</td><td>Radius of harmonics reference sphere. </td></tr>
    <tr><td class="paramname">preMultiplier</td><td>Generic multiplication factor. </td></tr>
    <tr><td class="paramname">degree</td><td>Degree of the harmonic for which the gradient is to be computed. </td></tr>
    <tr><td class="paramname">order</td><td>Order of the harmonic for which the gradient is to be computed. </td></tr>
    <tr><td class="paramname">cosineHarmonicCoefficient</td><td>Coefficient which characterizes relative strengh of a harmonic term. </td></tr>
    <tr><td class="paramname">sineHarmonicCoefficient</td><td>Coefficient which characterizes relative strengh of a harmonic term. </td></tr>
    <tr><td class="paramname">legendrePolynomial</td><td>Value of associated Legendre polynomial with the same degree and order as the to be computed harmonic, and with the sine of the latitude coordinate as polynomial parameter. Make sure that the Legendre polynomial has the same normalization as the harmonic coefficients. </td></tr>
    <tr><td class="paramname">legendrePolynomialDerivative</td><td>Value of the derivative of parameter 'legendrePolynomial' with respect to the sine of the latitude angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with derivatives of potential field. The order is important! gradient( 0 ) = derivative with respect to radial distance, gradient( 1 ) = derivative with respect to latitude angle, gradient( 2 ) = derivative with respect to longitude angle. </dd></dl>

<p>Definition at line <a class="el" href="../../da/d06/spherical_harmonics_8cpp_source.html#l00075">75</a> of file <a class="el" href="../../da/d06/spherical_harmonics_8cpp_source.html">sphericalHarmonics.cpp</a>.</p>

<p>References <a class="el" href="../../da/d06/spherical_harmonics_8cpp_source.html#l00043">computePotentialGradient()</a>, <a class="el" href="../../d3/d4c/spherical_harmonics_8h_source.html#l00250">latitudeIndex</a>, <a class="el" href="../../d3/d4c/spherical_harmonics_8h_source.html#l00250">longitudeIndex</a>, <a class="el" href="../../d3/d4c/spherical_harmonics_8h_source.html#l00250">radiusIndex</a>, and <a class="el" href="../../df/d63/basic_mathematics_functions_8h_source.html#l00087">raiseToIntegerPower()</a>.</p>

</div>
</div>
<a class="anchor" id="ac64d30d8ff066d9c4ecee48c8b896d69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tudat::basic_mathematics::computePotentialGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>sphericalPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>preMultiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cosineHarmonicCoefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sineHarmonicCoefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>legendrePolynomial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>legendrePolynomialDerivative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="../../d8/d69/classtudat_1_1basic__mathematics_1_1_spherical_harmonics_cache.html">SphericalHarmonicsCache</a> &gt;&#160;</td>
          <td class="paramname"><em>sphericalHarmonicsCache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a vector with the derivatives of a generic potential field (defined by spherical harmonics). It is assumed that the potential field of a single harmonic is characterized by: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ U = A \left( \frac{ R }{ r} \right) ^{ n + 1} P _{ n, m } ( \sin \phi ) \left[ C _{ n, m } \cos( m \lambda ) + S _{ n, m } \sin( \lambda ) \right] \]" src="../../form_150.png"/>
</p>
<p> in which <img class="formulaInl" alt="$ A $" src="../../form_151.png"/> is the generic multiplication factor, <img class="formulaInl" alt="$ R $" src="../../form_152.png"/> is the radius of the harmonics reference sphere, <img class="formulaInl" alt="$ P _{ n, m }( \sin \phi ) $" src="../../form_153.png"/> is the associated Legendre polynomial with <img class="formulaInl" alt="$ \sin \phi $" src="../../form_154.png"/> as polynomial parameter, <img class="formulaInl" alt="$ r $" src="../../form_67.png"/> is the radial coordinate, <img class="formulaInl" alt="$ \phi $" src="../../form_84.png"/> is the latitude coordinate, <img class="formulaInl" alt="$ \lambda $" src="../../form_120.png"/> is the longitude coordinate, <img class="formulaInl" alt="$ n $" src="../../form_12.png"/> is the harmonics degree, <img class="formulaInl" alt="$ m $" src="../../form_59.png"/> is the harmonics order, <img class="formulaInl" alt="$ C _{ n, m } $" src="../../form_155.png"/> is the cosine harmonics coefficient, and <img class="formulaInl" alt="$ S _{ n, m } $" src="../../form_156.png"/> is the sine harmonics coefficient.</p>
<p>The potential derivatives are calculated through: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{ \mathrm{ d } U }{ \mathrm{ d } r } = -\frac{ A }{ r } \left( \frac{ R }{ r } \right) ^{ n + 1 } ( n + 1 ) P_{ n, m }( \sin \phi )[ C_{ n, m } \cos( m \lambda ) + S_{ n,m } \sin( m \lambda ) ] \\ \frac{ \mathrm{ d } U }{ \mathrm{ d } \phi } = A \left( \frac{ R }{ r } \right)^{ n + 1 } \frac{ \mathrm{ d } [ P( \sin \phi ) ] }{ \mathrm{ d } [ \sin \phi ] } \cos \phi [ C_{ n, m } \cos( m \lambda ) + S_{ n, m } \sin( m \lambda ) ] \\ \frac{ \mathrm{ d } U }{ \mathrm{ d } \lambda } = A \left( \frac{ R }{ r } \right)^{ n + 1 } m P_{ n, m }( \sin \phi ) [ S_{ n, m } \cos( m \lambda ) - C_{ n, m } \sin( m \lambda ) ] \end{eqnarray*}" src="../../form_157.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sphericalPosition</td><td>Vector with spherical coordinates. The order is important! sphericalPosition( 0 ) = radial coordinate, sphericalPosition( 1 ) = latitude coordinate, sphericalPosition( 2 ) = longitude coordinate. </td></tr>
    <tr><td class="paramname">preMultiplier</td><td>Generic multiplication factor. </td></tr>
    <tr><td class="paramname">degree</td><td>Degree of the harmonic for which the gradient is to be computed. </td></tr>
    <tr><td class="paramname">order</td><td>Order of the harmonic for which the gradient is to be computed. </td></tr>
    <tr><td class="paramname">cosineHarmonicCoefficient</td><td>Coefficient which characterizes relative strengh of a harmonic term. </td></tr>
    <tr><td class="paramname">sineHarmonicCoefficient</td><td>Coefficient which characterizes relative strengh of a harmonic term. </td></tr>
    <tr><td class="paramname">legendrePolynomial</td><td>Value of associated Legendre polynomial with the same degree and order as the to be computed harmonic, and with the sine of the latitude coordinate as polynomial parameter. Make sure that the Legendre polynomial has the same normalization as the harmonic coefficients. </td></tr>
    <tr><td class="paramname">legendrePolynomialDerivative</td><td>Value of the derivative of parameter 'legendrePolynomial' with respect to the sine of the latitude angle. </td></tr>
    <tr><td class="paramname">sphericalHarmonicsCache</td><td>Cache object containing current values of trigonometric funtions of latitude anf longitude, as well as legendre polynomials at current state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with derivatives of potential field. The order is important! gradient( 0 ) = derivative with respect to radial distance, gradient( 1 ) = derivative with respect to latitude angle, gradient( 2 ) = derivative with respect to longitude angle. </dd></dl>

<p>Definition at line <a class="el" href="../../da/d06/spherical_harmonics_8cpp_source.html#l00097">97</a> of file <a class="el" href="../../da/d06/spherical_harmonics_8cpp_source.html">sphericalHarmonics.cpp</a>.</p>

<p>References <a class="el" href="../../da/d06/spherical_harmonics_8cpp_source.html#l00043">computePotentialGradient()</a>, and <a class="el" href="../../d3/d4c/spherical_harmonics_8h_source.html#l00250">radiusIndex</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a514fd17ae4b3bc45191ece95ca3d8b15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/d1f/classtudat_1_1basic__mathematics_1_1_legendre_cache.html#aa09fa0b6f9b5fc3ce708d5f365d0f6f4">LegendreCache::LegendrePolynomialFunction</a> tudat::basic_mathematics::geodesyNormalizedLegendrePolynomialFunction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">        boost::bind( &amp;<a class="code" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a16c6b72f4a30ea76e48b11f72e3f7f6a">computeGeodesyLegendrePolynomialFromCache</a>, _1, _2, _3 )</div><div class="ttc" id="namespacetudat_1_1basic__mathematics_html_a16c6b72f4a30ea76e48b11f72e3f7f6a"><div class="ttname"><a href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a16c6b72f4a30ea76e48b11f72e3f7f6a">tudat::basic_mathematics::computeGeodesyLegendrePolynomialFromCache</a></div><div class="ttdeci">double computeGeodesyLegendrePolynomialFromCache(const int degree, const int order, LegendreCache &amp;geodesyLegendreCache)</div><div class="ttdoc">Compute geodesy-normalized associated Legendre polynomial. </div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00393">legendrePolynomials.cpp:393</a></div></div>
</div><!-- fragment -->
<p>Definition at line <a class="el" href="../../db/d81/legendre_polynomials_8h_source.html#l00621">621</a> of file <a class="el" href="../../db/d81/legendre_polynomials_8h_source.html">legendrePolynomials.h</a>.</p>

<p>Referenced by <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00028">tudat::basic_mathematics::LegendreCache::LegendreCache()</a>.</p>

</div>
</div>
<a class="anchor" id="a8bbcf01f29c18b310ddeadaaef054859"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/d1f/classtudat_1_1basic__mathematics_1_1_legendre_cache.html#aa09fa0b6f9b5fc3ce708d5f365d0f6f4">LegendreCache::LegendrePolynomialFunction</a> tudat::basic_mathematics::regularLegendrePolynomialFunction</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">        boost::bind( &amp;<a class="code" href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a425517e4019a24999ca565085604a6c2">computeLegendrePolynomialFromCache</a>, _1, _2, _3 )</div><div class="ttc" id="namespacetudat_1_1basic__mathematics_html_a425517e4019a24999ca565085604a6c2"><div class="ttname"><a href="../../d0/df3/namespacetudat_1_1basic__mathematics.html#a425517e4019a24999ca565085604a6c2">tudat::basic_mathematics::computeLegendrePolynomialFromCache</a></div><div class="ttdeci">double computeLegendrePolynomialFromCache(const int degree, const int order, LegendreCache &amp;legendreCache)</div><div class="ttdoc">Compute unnormalized associated Legendre polynomial. </div><div class="ttdef"><b>Definition:</b> <a href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00310">legendrePolynomials.cpp:310</a></div></div>
</div><!-- fragment -->
<p>Definition at line <a class="el" href="../../db/d81/legendre_polynomials_8h_source.html#l00637">637</a> of file <a class="el" href="../../db/d81/legendre_polynomials_8h_source.html">legendrePolynomials.h</a>.</p>

<p>Referenced by <a class="el" href="../../d2/d5e/legendre_polynomials_8cpp_source.html#l00028">tudat::basic_mathematics::LegendreCache::LegendreCache()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 7 2017 11:20:31 for Tudat by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
